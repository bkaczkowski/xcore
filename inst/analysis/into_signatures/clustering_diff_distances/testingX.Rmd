---
title: "TGFbeta project"
author: "Migdal"
date: "8/18/2021"
output: pdf_document
---

# Notes
Subtracting U before modeling or including it as an offset gives equivalent
results.

Using intercept or not gives similar results, especially mean estimates on
parameters are perfectly correlated.

```{r include=FALSE}
knitr::opts_chunk$set(warning = FALSE, message = FALSE)

devtools::load_all()
doMC::registerDoMC(10L)
data("promoters_f5_core", "remap_promoters_f5", package = "xcoredata")
```

# TGFbeta expression data
Here I load symbol counts from TGFbeta experiment. The data are filtered and CPM
normalized by group, giving a matrix of per time point expression values.
For the initial analysis I will only look at 24h time point.
```{r eval=FALSE}
exprss_files <- list(
  system.file("inst", "extdata", "TGFbeta_counts_entrez.rda",
              package = "xcore"),
  system.file("inst", "extdata", "TGFbeta_counts_symbol.rda",
              package = "xcore"),
  system.file("inst", "extdata", "TGFbeta_counts_dpi.rda",
              package = "xcore"))
for(e in exprss_files) load(e)
rm(e)
```

# Create design matrix
Here we look at 24h samples only
```{r eval=FALSE}
# construct sample matrix
samples <- data.frame(
  samples_names = counts_symbol %>% colnames(),
  exp_fac = counts_symbol %>%
    colnames() %>%
    sub(pattern = "_R.", replacement = ""),
  stringsAsFactors = FALSE) %>%
  dplyr::filter(grepl("00|24", samples_names))

# construct design matrix
design_mat <- model.matrix(~ 0 + exp_fac, data = samples)
colnames(design_mat) <- sub( "exp_fac", "" , colnames(design_mat))
rownames(design_mat) <- samples$samples_names

designA <- design_mat[
  grepl("A_", rownames(design_mat)),
  grepl("A_", colnames(design_mat)),
  drop = FALSE
  ]


designM <- design_mat[
  grepl("M_", rownames(design_mat)),
  grepl("M_", colnames(design_mat)),
  drop = FALSE
  ]
```

# Prepare count input for regression
```{r eval=FALSE}
symbol2dpi <- stats::setNames(promoters_f5_core$name, promoters_f5_core$SYMBOL)

mat <- counts_dpi[, grep("A_.*(00|24)", colnames(counts_dpi))]
base_lvl <- "A_TGFb_00h"
dataA_dpi <- prepareCountsForRegression(
  counts = mat,
  base_lvl = base_lvl,
  design = designA,
  log2 = TRUE,
  pseudo_count = 1L)

mat <- counts_dpi[, grep("M_.*(00|24)", colnames(counts_dpi))]
base_lvl <- "M_TGFb_00h"
dataM_dpi <- prepareCountsForRegression(
  counts = mat,
  base_lvl = base_lvl,
  design = designM,
  log2 = TRUE,
  pseudo_count = 1L)
```

# Load signatures

```{r eval=FALSE}
collapsed_sig_names <- list.files(pattern = "remap_promoters.*rda$") %>%
  sub(pattern = "\\.rda", replacement = "")
collapsed_sig_files <- list.files(pattern = "remap_promoters.*rda$", full.names = TRUE)
for (sig in collapsed_sig_files) load(sig)

# hot fix
for (sig in collapsed_sig_names) {
  s <- get(sig)
  if (is.null(colnames(s))) {
    colnames(s) <- colnames(get(sub("_rowsum", "_0.3",  sig)))
    assign(x=sig, value=s)
  }
}
```

# Combine expression with signatures
Here I use MultiAssayExperiment as a container for expression and signatures.
They are matched based on promoter ids than intersection of the names is taken.
Since we are using SYMBOL counts and DPI signatures so we will need to convert
DPI's to SYMBOL's.

Additionally we filter out signatures overlapping less than 5% of promoters or
more than 95% of promoters.

```{r eval=FALSE}
signatures_to_add <- lapply(collapsed_sig_names, get)
names(signatures_to_add) <- collapsed_sig_names
signatures_to_add[["remap"]] <- remap_promoters

# A-549
signatures_to_add[["mae"]] <- dataA_dpi
dataA_dpi <- do.call(addSignatures, signatures_to_add)
dataA_dpi <- filterSignatures(dataA_dpi)

# MDA-MB-231
signatures_to_add[["mae"]] <- dataM_dpi
dataM_dpi <- do.call(addSignatures, signatures_to_add)
dataM_dpi <- filterSignatures(dataM_dpi)

for (sig in collapsed_sig_names) {rm(list = sig)}
rm(signatures_to_add)
gc()
```

# Signatures processing
## Ridge regression

```{r eval=FALSE}
regression <- list(A_549 = list(), MDA_MB_231 = list())

# A-549
## DPI
xnames <- setdiff(names(dataA_dpi), c("U", "Y"))
regression[["A_549"]][["DPI"]] <- modelGeneExpression(
  mae = dataA_dpi,
  yname = "Y",
  uname = "U",
  xnames = xnames,
  pvalues = FALSE,
  precalcmodels = regression[["A_549"]][["DPI"]][["regression_models"]]
  )
save(regression, file = "regression.rda")

# MDA-MB-231
## DPI
xnames <- setdiff(names(dataM_dpi), c("U", "Y"))
regression[["MDA_MB_231"]][["DPI"]] <- modelGeneExpression(
  mae = dataM_dpi,
  yname = "Y",
  uname = "U",
  xnames = xnames,
  pvalues = FALSE,
  precalcmodels = regression[["MDA_MB_231"]][["DPI"]][["regression_models"]]
  )
save(regression, file = "regression.rda")
```

```{r}
load("regression.rda")
```

# R2
## A-549 24h
```{r eval=FALSE}
doMC::registerDoMC(1L)
xnames <- setdiff(names(dataA_dpi), c("U", "Y"))
rsqA <- foreach(nm = xnames, .inorder = TRUE, .final = function(x) setNames(x, xnames)) %:%
  foreach(i = seq_len(4L), .combine = c) %dopar%
    estimateStat(
      x = dataA_dpi[[nm]],
      y = dataA_dpi[["Y"]][, i],
      u = dataA_dpi[["U"]],
      s = regression[["A_549"]][["DPI"]][["regression_models"]][[nm]][[i]]$lambda.min,
      nfold = 5,
      statistic = rsq)
save(rsqA, file = "rsqA.rda")
```

```{r}
load("rsqA.rda")
```

```{r}
library(ggplot2)

rsqA_df <- lapply(
  X = setdiff(names(rsqA), "remap"),
  FUN = function(nm) {
    x <- sub(pattern = "remap_promoters_", replacement = "", x = nm) %>%
      stringr::str_split(pattern = "_", n = 3) %>%
      unlist()
    data.frame(
      distance = x[1],
      cutoff = as.numeric(x[2]),
      collapsing = x[3],
      mean = mean(rsqA[[nm]]),
      stringsAsFactors = FALSE
    )
  }) %>%
  do.call(what = rbind)

ggplot(
  data = rsqA_df,
  aes(
    x = cutoff,
    y = mean,
    color = distance,
    linetype = collapsing
  )
) +
  geom_line() +
  geom_hline(yintercept = mean(rsqA[["remap"]]), linetype = "dashed") +
  xlab("Clustering cut-off") +
  ylab(expression(R ^ 2)) +
  ggtitle("Comparison of different signatures clustering approaches")

ggplot(
  data = rsqA_df[rsqA_df$distance == "pearson", ],
  aes(
    x = cutoff,
    y = mean,
    color = distance,
    linetype = collapsing
  )
) +
  geom_line() +
  geom_hline(yintercept = mean(rsqA[["remap"]]), linetype = "dashed") +
  xlab("Clustering cut-off") +
  ylab(expression(R ^ 2)) +

  ggtitle("Comparison of different signatures clustering approaches\nPearson distance")
```
