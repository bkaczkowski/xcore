---
title: "Deeper look into the 'signatures'"
author: "Maciej Migda≈Ç"
output: pdf_document
---

```{r include=FALSE}
knitr::opts_chunk$set(warning = FALSE, message = FALSE)

devtools::load_all()
library(data.table)

data(
  "promoters_f5",
  "promoters_f5_core",
  "remap_promoters_f5",
  "chip_atlas_promoters_f5",
  "remap_meta",
  "chip_atlas_meta",
  package = "xcoredata"
)
```

# Load additional annotations
Here we extend FANTOM5 promoter annotation by calculating tissue specificity tau
based on FANTOM5 expression data, adding tissue and cell type specificity
as defined in Protein Atlas, adding ENCODE blacklisted regions annotation,
adding ENSEMBL soft masked regions annotation.

```{r}
# Calculate Tau
#
# \code{tau} calculate Tau tissue-specificity metric.
# \deqn{\tau = \frac{\sum_{i=1}^{n} (1-\hat{x_i})}{n-1}; \hat{x_i} = \frac{x_i}{max(x)}}
# \link[https://academic.oup.com/bib/article/18/2/205/2562739]{Reference}.
#
# @param x Numeric vector giving expression of one gene in different tissues.
#
# @return Tau tissue-specificity metric.
#
tau <- function(x) {
  stopifnot(is.numeric(x) && length(x) > 1)

  if (all(!is.na(x)))
  {
    if (min(x, na.rm = TRUE) >= 0)
    {
      if (max(x) != 0)
      {
        x <- (1 - (x / max(x)))
        res <- sum(x, na.rm = TRUE)
        res <- res / (length(x) - 1)
      } else {
        res <- 0
      }
    } else {
      stop("Expression values have to be positive!")
    }
  } else {
    stop("No data for this gene avalable.")
  }

  return(res)
}

# tissue specificity tau
# Matrix of promoters normalized expression across datasets in FANTOM5,
# column names are not imported!
promoters_f5_expression <-
  data.table::fread(
    file = system.file("inst",
                       "extdata",
                       "hg38_fair+new_CAGE_peaks_phase1and2_tpm.osc.txt.gz",
                       package = "xcore"),
    header = TRUE)
promoters_f5_expression <-
  data.table::melt(data = promoters_f5_expression,
                   id.vars = "00Annotation")
promoters_f5_tau <-
  promoters_f5_expression[,
                          .(t = tau(log(value + 1))),
                          by = "00Annotation"
  ]

promoters_f5$tau <- GenomicRanges::mcols(promoters_f5) %>%
  as.data.frame() %>%
  dplyr::left_join(y = promoters_f5_tau[, c("00Annotation", "t")],
                   by = c("name" = "00Annotation")) %>%
  dplyr::pull(t)

rm(promoters_f5_expression, promoters_f5_tau); gc()

# tissue specificity protein atlass
protein_atlas <-
  data.table::fread(
    file = system.file("inst", "extdata", "proteinatlas.tsv.gz", package = "xcore"),
    header = TRUE
  )[! duplicated(Gene), ]
data.table::setnames(protein_atlas,
                     c("RNA tissue specificity",
                     "RNA single cell type specificity"),
                     c("protein_atlas_tissue_specificity",
                       "protein_atlas_cell_specificity"))

GenomicRanges::mcols(promoters_f5) <- GenomicRanges::mcols(promoters_f5) %>%
  as.data.frame() %>%
  dplyr::left_join(y = protein_atlas[, c("Gene",
                                         "protein_atlas_tissue_specificity",
                                         "protein_atlas_cell_specificity")],
                   by = c("SYMBOL" = "Gene"))

rm(protein_atlas); gc()

# ENCODE blacklisted regions
blacklist <- rtracklayer::import(system.file("inst",
                                             "extdata",
                                             "hg38-blacklist.v2.bed.gz",
                                             package = "xcore")) %>%
  IRanges::subsetByOverlaps(x = promoters_f5,
                            type = "any") %>%
  GenomicRanges::mcols() %>%
  `[[`("name")
promoters_f5$encode_blacklist <- promoters_f5$name %in% blacklist

rm(blacklist); gc()

# ENSEMBL soft masked regions
ensembl_sm <- rtracklayer::import(system.file("inst",
                                              "extdata",
                                              "hg38_ensembl_sm.bed.gz",
                                              package = "xcore")) %>%
  IRanges::subsetByOverlaps(x = promoters_f5,
                            type = "any") %>%
  GenomicRanges::mcols() %>%
  `[[`("name")
promoters_f5$ensembl_sm <- promoters_f5$name %in% ensembl_sm

rm(ensembl_sm); gc()
```

# Technical biases and noise vs biological signal.

Based on the Bogumil's observation that some promoters always give a signal
regardless on the transcription factor we look at. As well as, some TF gives
signal regardless of the promoter we look at. We set out with an exploratory
data analysis on the ReMap2020 and ChIP-Atlas data sets.

To look deeper into those data sets, first we have limited our analysis to
core promoters defined as promoters associated with a protein coding gene (as
per GENCODE 38) and supported by ENCODE ROADMAP data. Finally, we select one
promoter per associated gene that have maximum FANTOM5 score.

```{r core_promoters}
# add annotations to core promoters
promoters_ann_core <- promoters_f5[promoters_f5$name %in% promoters_f5_core$name, ]

# restrict interaction matrices to core promoters only
remap_promoters_f5_core <- remap_promoters_f5[promoters_ann_core$name, ]
chip_atlas_promoters_f5_core <- chip_atlas_promoters_f5[promoters_ann_core$name, ]
```

This give us an interaction matrix with `r nrow(remap_promoters_f5_core)` promoters
(rows) and `r ncol(remap_promoters_f5_core)`, `r ncol(chip_atlas_promoters_f5_core)`
ChIP-seq experiments (columns) for ReMap2020, ChIP-Atlas respectively.

## Looking at promoter TF interaction matrix row wise (promoter wise)

ReMap2020 and ChIP-Atlas were intersected with FANTOM5 promoters into
interaction matrices with ChIP-seq experiment as a columns and promoters as a
row names. Overall our data included `r nrow(remap_promoters_f5)` promoters and
`r ncol(remap_promoters_f5)`, `r ncol(chip_atlas_promoters_f5)` ChIP-seq experiments
for ReMap2020, ChIP-Atlas respectively.

### Promoter coverage

For each promoter we calculate coverage which is equal to the number
of ChIP-seq experiment the promoter intersect with.

```{r promoters_coverage}
# remap
promoters_ann_core$remap_coverage <- remap_promoters_f5_core %>% Matrix::rowSums()
# chip_atlas
promoters_ann_core$chip_atlas_coverage <- chip_atlas_promoters_f5_core %>% Matrix::rowSums()
```

```{r promoters_coverage_hist}
par(mfrow = c(1, 2), cex = 0.7, pty = "s")

# Promoter coverage histogram
plotHistogram(x = promoters_ann_core$remap_coverage,
             main = "ReMap2020 promoter coverage",
             ylim = c(0, 1000),
             xlim = c(0, 5000))
plotHistogram(x = promoters_ann_core$chip_atlas_coverage,
             main = "ChIP-Atlas promoter coverage",
             ylim = c(0, 1000),
             xlim = c(0, 5000))
```

For some promoters we observe no coverage at all:
`r sum(promoters_ann_core$remap_coverage == 0)`,
`r sum(promoters_ann_core$chip_atlas_coverage == 0)`
for ReMap2020, ChIP-Atlas respectively.


### Protein Atlas gene specificity classification

We investigate promoters coverage by looking at their target genes
classification in terms of tissue/cell type specificity as defined by Protein
Atlas.

> The RNA specificity category is based on mRNA expression levels in a
combination of data from HPA, GTEX and FANTOM5. The categories include:
tissue enriched, group enriched, tissue enhanced, low tissue specificity and not
detected.

>
+ Enriched - NX level in a particular tissue/region/cell type at least four
times any other tissue/cell type.
+ Group enriched - NX levels of a group (2-5 tissues or 2-10 cell types) at
least four times any other tissue/cell type.
+ Enhanced - NX levels of a group (1-5 tissues or 1-10 cell types) at least four
times the mean of other tissue/cell types.
+ Low specificity - NX >= 1 in at least one tissue/cell type but not elevated in
any tissue/cell type.
+ Not detected - NX < 1 in all tissue/cell types.

[Protein Atlas](https://www.proteinatlas.org/about/assays+annotation#classification_rna)

```{r protein_atlas_promoters}
# RNA tissue specificity
par(mfrow = c(1, 2), cex = 0.7, pty = "s")
ymax <-
  max(promoters_ann_core$remap_coverage,
      promoters_ann_core$chip_atlas_coverage)
graphics::boxplot(remap_coverage ~ protein_atlas_cell_specificity,
                  data = promoters_ann_core,
                  ylim = c(0, ymax),
                  main = "ReMap2020",
                  ylab = "promoter coverage",
                  xlab = "",
                  las=2,
                  cex.names = 0.4)
graphics::boxplot(chip_atlas_coverage ~ protein_atlas_cell_specificity,
                  data = promoters_ann_core,
                  ylim = c(0, ymax),
                  main = "ChIP-Atlas",
                  ylab = "promoter coverage",
                  xlab = "",
                  las=2,
                  cex.names = 0.4)
mtext(
  "Protein Atlas tissue specificity",
  side = 3,
  outer = TRUE,
  line = -2,
  font = 2,
  cex = 1.2
)
```

### Promoter tissue specificity

To generalize the idea of promoter tissue/cell type specificity to promoters
outside Protein Atlas annotation we define specificity score based on the
FANTOM5 CAGE data.

The  can be defined in multiple ways. Here we calculate expression based
specificity score using $\tau$ metric defined as

$\tau = \frac{\sum_{i=1}^{n} (1-\hat{x_i})}{n-1}; \hat{x_i} = \frac{x_i}{max(x)}$

Tau varies from 0 to 1, where 0 means broadly expressed, and 1 is specific.

[reference](https://academic.oup.com/bib/article/18/2/205/2562739#119555186).

```{r promoter_f5_specificity_boxplot}
graphics::boxplot(tau ~ protein_atlas_tissue_specificity,
                  data = promoters_ann_core,
                  main = "Tau vs Protein Atlass classififcation",
                  ylab = expression(tau),
                  xlab = "",
                  cex.axis = 0.8)
```


```{r promoters_f5_tau_hist}
plotHistogram(x = promoters_ann_core$tau,
             main = expression(paste("core promoters ", tau, " distribution")))
```

```{r promoter_f5_specificity_scatter}
par(mfrow = c(1, 2), cex = 0.7, pty = "s", mgp=c(2,1,0))
with(
  as.data.frame(promoters_ann_core),
  graphics::smoothScatter(
    x = remap_coverage,
    y = tau,
    main = sprintf(
      "ReMap2020\nSpearman: %f",
      cor(x = remap_coverage,
          y = tau,
          method = "spearman")
    ),
    ylab = expression(tau),
    xlab = "promoter coverage"
  )
)
with(
  as.data.frame(promoters_ann_core),
  graphics::smoothScatter(
    x = chip_atlas_coverage,
    y = tau,
    main = sprintf(
      "ChIP-Atlas\nSpearman: %f",
      cor(x = chip_atlas_coverage,
          y = tau,
          method = "spearman")
    ),
    ylab = expression(tau),
    xlab = "promoter coverage"
  )
)
mtext(
  "Promoter coverage vs tau",
  side = 3,
  outer = TRUE,
  line = -2,
  font = 2,
  cex = 1.2
)
```

### ENCODE blacklist

We investigate promoters coverage by overlapping the promoters with ENCODE's
list of blacklisted regions.

>  ENCODE blacklist is a comprehensive set of regions in the human and other
genomes that have anomalous, unstructured, or high signal in next-generation
sequencing experiments independent of cell line or experiment. The removal of
the ENCODE blacklist is an essential quality measure when analyzing functional
genomics data.
[ENCODE blacklist](https://github.com/Boyle-Lab/Blacklist)

```{r blacklisted_promoters}
par(mfrow = c(1, 2), cex = 0.7, pty = "s")
ymax <-
  max(promoters_ann_core$remap_coverage,
      promoters_ann_core$chip_atlas_coverage)
with(
  as.data.frame(promoters_ann_core),
  boxplot(
    remap_coverage[encode_blacklist],
    remap_coverage[!encode_blacklist],
    names = c(sprintf(
      "blacklisted (%i)", sum(encode_blacklist)
    ),
    sprintf("other (%i)", sum(!encode_blacklist))),
    ylim = c(0, ymax),
    main = "ReMap2020",
    ylab = "promoter coverage"
  )
)
with(
  as.data.frame(promoters_ann_core),
  boxplot(
    chip_atlas_coverage[encode_blacklist],
    chip_atlas_coverage[!encode_blacklist],
    names = c(sprintf(
      "blacklisted (%i)", sum(encode_blacklist)
    ),
    sprintf("other (%i)", sum(!encode_blacklist))),
    ylim = c(0, ymax),
    main = "ChIP-Atlas",
    ylab = "promoter coverage"
  )
)
mtext(
  "ENCODE blacklisted regions",
  side = 3,
  outer = TRUE,
  line = -2,
  font = 2,
  cex = 1.2
)
```

### Promoters score (width) vs coverage

We investigate promoters coverage by looking at the relations between promoter
coverage and score, or width.

```{r promoter_score_length}
# Promoters coverage vs score
par(mfrow = c(1, 2), cex = 0.7, pty = "s")
graphics::smoothScatter(
     x = promoters_ann_core$remap_coverage,
     y = log10(promoters_ann_core$score),
     main = sprintf("ReMap2020\nSpearman: %f",
                    cor(x = promoters_ann_core$remap_coverage,
                        y = log10(promoters_ann_core$score),
                        method = "spearman")),
     xlab = "promoter coverage",
     ylab = "log10(promoter score)")
graphics::smoothScatter(
     x = promoters_ann_core$chip_atlas_coverage,
     y = log10(promoters_ann_core$score),
     main = sprintf("ChIP-Atlas\nSpearman: %f",
                    cor(x = promoters_ann_core$chip_atlas_coverage,
                        y = log10(promoters_ann_core$score),
                        method = "spearman")),
     xlab = "promoter coverage",
     ylab = "log10(promoter score)")
mtext(
  "Promoter coverage vs promoter score",
  side = 3,
  outer = TRUE,
  line = -2,
  font = 2,
  cex = 1.2
)

# Promoters coverage vs width
graphics::smoothScatter(
     x = promoters_ann_core$remap_coverage,
     y = GenomicRanges::width(promoters_ann_core),
     main = sprintf("ReMap2020\nSpearman: %f",
                    cor(x = promoters_ann_core$remap_coverage,
                        y = GenomicRanges::width(promoters_ann_core),
                        method = "spearman")),
     xlab = "promoter coverage",
     ylab = "promoter width")
graphics::smoothScatter(
     x = promoters_ann_core$chip_atlas_coverage,
     y = GenomicRanges::width(promoters_ann_core),
     main = sprintf("ChIP-Atlas\nSpearman: %f",
                    cor(x = promoters_ann_core$chip_atlas_coverage,
                        y = GenomicRanges::width(promoters_ann_core),
                        method = "spearman")),
     xlab = "promoter coverage",
     ylab = "promoter width")
mtext(
  "Promoter coverage vs promoter width",
  side = 3,
  outer = TRUE,
  line = -2,
  font = 2,
  cex = 1.2
)
```

## Looking at promoter TF interaction matrix column wise (TF wise)

### TF overlapp between ReMap2020 and ChIP-Atlas

```{r}
# ReMap2020
table((remap_meta$tf %in% chip_atlas_meta$tf)) %>%
  `/`(length(remap_meta$tf)) %>%
  data.frame() %>%
  dplyr::rename(TF = Var1) %>%
  dplyr::mutate(TF = c("not included in ChIP-Atlas", "included in ChIP-Atlas")) %>%
  knitr::kable(caption = "ReMap2020 TF")

table(unique(remap_meta$tf) %in% unique(chip_atlas_meta$tf)) %>%
  `/`(length(unique(remap_meta$tf))) %>%
  data.frame() %>%
  dplyr::rename(TF = Var1) %>%
  dplyr::mutate(TF = c("not included in ChIP-Atlas", "included in ChIP-Atlas")) %>%
  knitr::kable(caption = "ReMap2020 unique TF")

remap_meta$tf[! remap_meta$tf %in% chip_atlas_meta$tf] %>%
  table() %>%
  as.numeric() %>%
  plotHistogram(breaks = "Sturges",
               main = "ReMap2020 TF not included in ChIP-Atlas")

# ChIP-Atlas
table((chip_atlas_meta$tf %in% remap_meta$tf)) %>%
  `/`(length(chip_atlas_meta$tf)) %>%
  data.frame() %>%
  dplyr::rename(TF = Var1) %>%
  dplyr::mutate(TF = c("not included in ReMap2020", "included in ReMap2020")) %>%
  knitr::kable(caption = "ChIP-Atlas TF")

table(unique(chip_atlas_meta$tf) %in% unique(remap_meta$tf)) %>%
  `/`(length(unique(chip_atlas_meta$tf))) %>%
  data.frame() %>%
  dplyr::rename(TF = Var1) %>%
  dplyr::mutate(TF = c("not included in ChIP-Atlas", "included in ChIP-Atlas")) %>%
  knitr::kable(caption = "ChIP-Atlas unique TF")

chip_atlas_meta$tf[! chip_atlas_meta$tf %in% remap_meta$tf] %>%
  table() %>%
  as.numeric() %>%
  plotHistogram(breaks = "Sturges",
               main = "ChIP-Atlas TF not included in ChIP-Atlas")
```

```{r}
remap_meta[, coverage := Matrix::colSums(remap_promoters_f5_core[, id])]
chip_atlas_meta[, coverage := Matrix::colSums(chip_atlas_promoters_f5_core[, id])]
```

For the basic analysis we have focused only on subset of ReMap2020 and
ChIP-Atlas. Choosing only experiments that overlap more than 1% of
core promoters. Additionally for ReMap2020 we took only experiments without
condition or treatment label.

Further we focused only on TF with >= 10 experiments and for ReMap2020 biotypes
with >= 29 experiments, excluding the "breast" and "liver" biotypes, and for
ChIP-Atlas biotypes with >= 50 experiments, excluding the "Breast.cancer.cells",
"Breast.cancer", "Prostate", "Lymphoblastoid.cell.line", "Macrophages".

```{r}
# ReMap2020
remap_meta_core <- remap_meta[(coverage >= (nrow(remap_promoters_f5_core) * 0.01)) &
                                (condition == "")]

sel_tf <- remap_meta_core$tf %>%
  table() %>%
  `[`(. >= 10) %>%
  names()
remap_meta_core <- remap_meta_core[tf %in% sel_tf]

sel_biotypes <- remap_meta_core$biotype %>%
  table() %>%
  `[`(. >= 29) %>%
  names() %>%
  `[`(! . %in% c("breast", "liver"))
remap_meta_core <- remap_meta_core[biotype %in% sel_biotypes]

# annotate coverage
remap_meta_core[, cov_type := cut(
  coverage,
  breaks = c(0, quantile(coverage, 0.25), quantile(coverage, 0.75), Inf),
  labels = c("low", "medium", "high")
)]

# ChIP-Atlas
chip_atlas_meta_core <-
  chip_atlas_meta[coverage >= (nrow(remap_promoters_f5_core) * 0.01)]

sel_tf <- chip_atlas_meta_core$tf %>%
  table() %>%
  `[`(. >= 10) %>%
  names()
chip_atlas_meta_core <- chip_atlas_meta_core[tf %in% sel_tf]

sel_biotypes <- chip_atlas_meta_core$biotype %>%
  table() %>%
  `[`(. >= 50) %>%
  names() %>%
  `[`(! . %in% c("Breast.cancer.cells", "Breast.cancer", "Prostate", "Lymphoblastoid.cell.line", "Macrophages"))
chip_atlas_meta_core <- chip_atlas_meta_core[biotype %in% sel_biotypes]

# annotate coverage
chip_atlas_meta_core[, cov_type := cut(
  coverage,
  breaks = c(0, quantile(coverage, 0.25), quantile(coverage, 0.75), Inf),
  labels = c("low", "medium", "high")
)]
```

```{r}
par(mfrow = c(1, 2), cex = 0.7, pty = "s")
plotHistogram(remap_meta_core$coverage,
              main = "ReMap2020")
plotHistogram(chip_atlas_meta_core$coverage,
              main = "ChIP-Atlas")
mtext(
  "Selected experiment's coverage",
  side = 3,
  outer = TRUE,
  line = -2,
  font = 2,
  cex = 1.2
)
```

### TF / biotype confusion matrix

```{r tf_bg_confusion_matrix_remap, echo=FALSE}
remap_tfs_tab <-
  data.table::dcast(data = remap_meta_core,
                    formula = biotype ~ tf,
                    fun = length)
ord <- c(1, order(remap_tfs_tab[, -1] %>% colSums(), decreasing = TRUE) + 1)
data.table::setcolorder(remap_tfs_tab, ord)
remap_tfs_tab[, .r := -rowSums(remap_tfs_tab[, -1])]
data.table::setorder(remap_tfs_tab, .r)[, .r := NULL]

knitr::kable(remap_tfs_tab[, 1:11], caption = "ReMap TF/biotype matrix, top 10 TF")
```

```{r tf_bg_confusion_matrix_chip_atlas, echo=FALSE}
chip_atlas_tfs_tab <-
  data.table::dcast(data = chip_atlas_meta_core,
                    formula = biotype ~ tf,
                    fun = length)
ord <- c(1, order(chip_atlas_tfs_tab[, -1] %>% colSums(), decreasing = TRUE) + 1)
data.table::setcolorder(chip_atlas_tfs_tab, ord)
chip_atlas_tfs_tab[, .r := -rowSums(chip_atlas_tfs_tab[, -1])]
data.table::setorder(chip_atlas_tfs_tab, .r)[, .r := NULL]

knitr::kable(chip_atlas_tfs_tab[, 1:11], caption = "ChIP-Atlas TF/biotype matrix, top 10 TF")
```

## Choosing distance measure
In order to select a distance measure that would best describe associations
between experiments, we have looked into several distance measures: Phi
(which we approximate with Pearson's), Gower, Jaccard, Dice, Yule, Russel,
Tanimoto. In order to select one we wanted to maximize the difference between
mean distance between the same TF and different TF.

The selection was done using core ReMap2020.

Outliers were not marked on plots.

```{r select_distance_measure}
mat <- remap_promoters_f5_core[, remap_meta_core[, id]] %>% as.matrix()

getDists <- function(mat, patterns, invert=FALSE) {
  sapply(
    X = patterns,
    function(x) {
      m_row <- grep(x, rownames(mat), value = TRUE)
      m_col <- grep(x, colnames(mat), value = TRUE, invert = invert)
      sel_cor_mat <- mat[m_row, m_col]
      sel_cor_mat[upper.tri(sel_cor_mat, diag = FALSE)]
    })
}

compDists <- function(D, Dnames, patterns) {
  Ds <- lapply(
    X = seq_along(D),
    FUN = function(i) {
      same_tf <- data.frame(metric = Dnames[i],
                            val = unlist(getDists(D[[i]], patterns)),
                            type = "same")
      diff_tf <- data.frame(metric = Dnames[i],
                            val = unlist(getDists(D[[i]], patterns, invert=TRUE)),
                            type = "diff.")
      rbind(same_tf, diff_tf)
    }
  ) %>% do.call(what = rbind)
}

# pearson approximates phi coefficient
d_pearson <- sqrt(1 - cor(mat, method = "pearson"))
# d_binary <- dist(t(mat), method = "binary") %>% as.matrix() equivalent to jaccard
d_gower <- cluster::daisy(t(mat), metric = "gower", warnType = FALSE) %>% as.matrix()
d_jaccard <- proxy::dist(x = mat,
                         method = "Jaccard",
                         by_rows = FALSE,
                         convert_similarities = TRUE) %>% proxy::as.matrix(diag = 0)

d_dice <- proxy::dist(x = mat,
                         method = "Dice",
                         by_rows = FALSE,
                         convert_similarities = TRUE) %>% proxy::as.matrix(diag = 0)

d_russel <- proxy::dist(x = mat,
                         method = "Russel",
                         by_rows = FALSE,
                         convert_similarities = TRUE) %>% proxy::as.matrix(diag = 0)

d_tanimoto <- proxy::dist(x = mat,
                         method = "Tanimoto",
                         by_rows = FALSE,
                         convert_similarities = TRUE) %>% proxy::as.matrix(diag = 0)

d_comparison <- compDists(
  list(d_pearson, d_gower, d_jaccard, d_dice, d_yule, d_yule2, d_russel, d_tanimoto),
  c("Phi", "Gower", "Jaccard", "Dice", "Yule", "Yule2", "Russel", "Tanimoto"),
  remap_meta_core[, unique(tf)])
par(mar = c(10, 4, 4, 1))
boxplot(val ~ type + metric,
        data = d_comparison,
        sep = " ",
        las=2,
        ylim = c(0, sqrt(2)),
        outline = FALSE,
        main = "Distances between experiments grouped by TF",
        ylab = "distance",
        xlab = "")

d_comparison %>%
  dplyr::group_by(type, metric) %>%
  dplyr::summarise(mean = mean(val)) %>%
  dplyr::group_by(metric) %>%
  dplyr::summarise(dAve = abs(mean[1] - mean[2])) %>%
  knitr::kable(col.names = c("Distance metric", "$\\Delta Average$"),
               caption = "Difference between mean distance between same and different TF groups",
               escape = FALSE)
```

## Experiments heatmaps

```{r}
breaks <- seq(from = -1, to = 1, by = 0.1)
color <-
  grDevices::colorRampPalette(rev(RColorBrewer::brewer.pal(
    n = 7,
    name = "RdBu"))
  )(length(breaks))

getPearsonMat <- function(sel_tf) {
  m <- remap_meta_core[tf == sel_tf, id]
  mat <- remap_promoters_f5_core[, remap_meta_core[, id]] %>% as.matrix()
  mat <- mat[, m]
  cor(mat, method = "pearson")
}

pearsonDist <- function(mat) {
  sqrt(1 - cor(mat, method = "pearson")) %>% as.dist()
}
```

### MYC

```{r}
mat <- getPearsonMat("MYC")
d <- pearsonDist(mat)
plotExperimentsHeatmap(
  mat = mat,
  meta = remap_meta_core[tf == "MYC", -c("tf", "condition", "tf_dbd")],
  clustering_distance_rows = d,
  clustering_distance_cols = d,
  clustering_method = "ward.D2",
  breaks = breaks,
  color = color,
  labels_row = remap_meta_core[tf == "MYC", biotype],
  labels_col = remap_meta_core[tf == "MYC", biotype],
  main = "ReMap2020: MYC experiments Pearson's r")
```
#### FOXA1 pearson

```{r}
mat <- getPearsonMat("FOXA1")
d <- pearsonDist(mat)
plotExperimentsHeatmap(
  mat = mat,
  meta = remap_meta_core[tf == "FOXA1", -c("tf", "condition", "tf_dbd", "cov_type")],
  clustering_distance_rows = d,
  clustering_distance_cols = d,
  clustering_method = "ward.D2",
  breaks = breaks,
  color = color,
  labels_row = remap_meta_core[tf == "FOXA1", biotype],
  labels_col = remap_meta_core[tf == "FOXA1", biotype],
  main = "ReMap2020: FOXA1 experiments Pearson's r")
```

### MAX

```{r}
mat <- getPearsonMat("MAX")
d <- pearsonDist(mat)
plotExperimentsHeatmap(
  mat = mat,
  meta = remap_meta_core[tf == "MAX", -c("tf", "condition", "tf_dbd")],
  clustering_distance_rows = d,
  clustering_distance_cols = d,
  clustering_method = "ward.D2",
  breaks = breaks,
  color = color,
  labels_row = remap_meta_core[tf == "MAX", biotype],
  labels_col = remap_meta_core[tf == "MAX", biotype],
  main = "ReMap2020: MAX experiments Pearson's r")
```

### HDAC2

```{r}
mat <- getPearsonMat("HDAC2")
d <- pearsonDist(mat)
plotExperimentsHeatmap(
  mat = mat,
  meta = remap_meta_core[tf == "HDAC2", -c("tf", "condition", "tf_dbd")],
  clustering_distance_rows = d,
  clustering_distance_cols = d,
  clustering_method = "ward.D2",
  breaks = breaks,
  color = color,
  labels_row = remap_meta_core[tf == "HDAC2", biotype],
  labels_col = remap_meta_core[tf == "HDAC2", biotype],
  main = "ReMap2020: HDAC2 experiments Pearson's r")
```

### REST

```{r}
mat <- getPearsonMat("REST")
d <- pearsonDist(mat)
plotExperimentsHeatmap(
  mat = mat,
  meta = remap_meta_core[tf == "REST", -c("tf", "condition", "tf_dbd")],
  clustering_distance_rows = d,
  clustering_distance_cols = d,
  clustering_method = "ward.D2",
  breaks = breaks,
  color = color,
  labels_row = remap_meta_core[tf == "REST", biotype],
  labels_col = remap_meta_core[tf == "REST", biotype],
  main = "ReMap2020: REST experiments Pearson's r")
```

## Clustering experiments

```{r}
i_0 <- apply(remap_promoters_f5_core, 2, function(x) var(x) == 0)
remap_dist <- remap_promoters_f5_core[, ! i_0] %>%
  as.matrix() %>%
  cor(method = "pearson")

i_0 <- apply(chip_atlas_promoters_f5_core, 2, function(x) var(x) == 0)
chip_atlas_dist <- chip_atlas_promoters_f5_core[, ! i_0] %>%
  as.matrix() %>%
  cor(method = "pearson")
```

### Hierarchical Clustering

```{r}
measureClust <- function(c1, hc, N) {
  nclust_measure <- lapply(
    X = N,
    FUN = function(n) {
      do.call(cbind,
              aricode::clustComp(c1 = c1,
                                 c2 = cutree(hc, n)))
    }
  )
  do.call(rbind, nclust_measure)
}

plotMeasureClust <- function(n_cl,
                             cl_measure,
                             measure,
                             ylim,
                             pos = "topright",
                             main = "",
                             add_legend = TRUE) {
  cols <- colorspace::qualitative_hcl(length(cl_measure))
  plot(
    x = NA,
    y = NA,
    main = main,
    xlim = c(min(n_cl), max(n_cl)),
    ylim = ylim,
    xlab = "number of clusters",
    ylab = measure
  )
  for (i in seq_along(cl_measure)) {
    points(n_cl, cl_measure[[i]][, measure], col = cols[i], pch = i)
  }
  if (add_legend) {
    legend(
      pos,
      legend = names(cl_measure),
      col = cols,
      pch = seq_along(cl_measure))
  }
}
```

### Linkage method choice

```{r}
nclust <- seq(from = 1, to = 400, by = 5)
linkage_methods <- c("complete", "single", "ward.D", "ward.D2", "average",
                     "mcquitty", "median", "centroid")

# ReMap2020
id_core <- rownames(remap_dist)
d_core <- as.dist(sqrt(1 - remap_dist))
data.table::setkey(remap_meta_core, tf)
true_cl <- remap_meta_core[id_core, tf]
clust_measures <- lapply(
  X = linkage_methods,
  FUN = function(m) {
    hc <- hclust(d_core, method = m)
    measureClust(true_cl, hc, nclust)
  })
names(clust_measures) <- linkage_methods

par(mfrow = c(1, 2), oma = c(0, 0, 4, 0), cex = 0.7, pty = "s")
plotMeasureClust(
  nclust,
  clust_measures,
  "ARI",
  ylim = c(0, 0.65),
  pos = "topright",
  main = "Adjusted Rand Index",
  add_legend = FALSE
)
plotMeasureClust(
  nclust,
  clust_measures,
  "AMI",
  ylim = c(0, 0.8),
  pos = "bottomright",
  main = "Adjusted Mutual Information"
)
mtext(
  "Hierarchical clustering performance\nfor different linkage methods\nReMap2020 core experiments",
  side = 3,
  outer = TRUE,
  line = -1,
  font = 2,
  cex = 0.9
)

# ChIP-Atlas
id_core <- rownames(chip_atlas_dist)
d_core <- as.dist(sqrt(1 - chip_atlas_dist))
data.table::setkey(chip_atlas_meta_core, tf)
true_cl <- chip_atlas_meta_core[id_core, tf]
clust_measures <- lapply(
  X = linkage_methods,
  FUN = function(m) {
    hc <- hclust(d_core, method = m)
    measureClust(true_cl, hc, nclust)
  })
names(clust_measures) <- linkage_methods

plotMeasureClust(
  nclust,
  clust_measures,
  "ARI",
  ylim = c(0, 0.65),
  pos = "topright",
  main = "Adjusted Rand Index"
)
plotMeasureClust(
  nclust,
  clust_measures,
  "AMI",
  ylim = c(0, 0.8),
  pos = "bottomright",
  main = "Adjusted Mutual Information"
)
mtext(
  "Hierarchical clustering performance\nfor different linkage methods\nChIP-Atlas core experiments",
  side = 3,
  outer = TRUE,
  line = -1,
  font = 2,
  cex = 0.9
)
```

### clustering as compared to known labels

```{r}
nclust <- seq(from = 1, to = 400, by = 5)
labels <- c("tf", "biotype", "study")

# ReMap2020
id_core <- remap_meta_core[, id]
d_core <- as.dist(as.matrix(d_yule_remap)[id_core, id_core])
labs_measure <- lapply(
  X = labels,
  FUN = function(l) {
    hc <- hclust(d_core, method = "ward.D2")
    measureClust(remap_meta_core[[l]], hc, nclust)
  })
names(labs_measure) <- labels

par(mfrow = c(1, 2), oma = c(0, 0, 3, 0), cex = 0.7, pty = "s")
plotMeasureClust(
  nclust,
  labs_measure,
  "ARI",
  ylim = c(0, 0.65),
  pos = "topright",
  main = "Adjusted Rand Index"
)
plotMeasureClust(
  nclust,
  labs_measure,
  "AMI",
  ylim = c(0, 0.8),
  pos = "bottomright",
  main = "Adjusted Mutual Information"
)
mtext(
  "Hierarchical clustering performance for different labels\nReMap2020 selected experiments",
  side = 3,
  outer = TRUE,
  line = -1,
  font = 2,
  cex = 1
)

# ChIP-Atlas
id_core <- chip_atlas_meta_core[, id]
d_core <- as.dist(as.matrix(d_yule_chip_atlas)[id_core, id_core])
labs_measure <- lapply(
  X = labels,
  FUN = function(l) {
    hc <- hclust(d_core, method = "ward.D2")
    measureClust(chip_atlas_meta_core[[l]], hc, nclust)
  })
names(labs_measure) <- labels

plotMeasureClust(
  nclust,
  labs_measure,
  "ARI",
  ylim = c(0, 0.65),
  pos = "topright",
  main = "Adjusted Rand Index"
)
plotMeasureClust(
  nclust,
  labs_measure,
  "AMI",
  ylim = c(0, 0.8),
  pos = "bottomright",
  main = "Adjusted Mutual Information"
)
mtext(
  "Hierarchical clustering performance for different labels\nChIP-Atlas selected experiments",
  side = 3,
  outer = TRUE,
  line = -1,
  font = 2,
  cex = 1
)
```

### Partitioning Around Medoids

```{r}
nclust <- seq(from = 1, to = 400, by = 10)
labels <- c("tf", "biotype", "study")

# ReMap2020
id_core <- remap_meta_core[, id]
d_core <- as.dist(as.matrix(d_yule_remap)[id_core, id_core])

cl_pam <- lapply(
  X = nclust,
  FUN = function(i) {
    cluster::pam(d_core, k = i, cluster.only = TRUE)
  })
cl_measure <- lapply(
  X = labels,
  FUN = function(l) {
    cbind(
      ARI = sapply(cl_pam, aricode::ARI, c1 = remap_meta_core[[l]]),
      AMI = sapply(cl_pam, aricode::AMI, c1 = remap_meta_core[[l]])
    )
  })
names(cl_measure) <- labels

par(mfrow = c(1, 2), oma = c(0, 0, 4, 0), cex = 0.7, pty = "s")
plotMeasureClust(
  nclust,
  cl_measure,
  "ARI",
  ylim = c(0, 0.65),
  pos = "topright",
  main = "Adjusted Rand Index"
)
plotMeasureClust(
  nclust,
  cl_measure,
  "AMI",
  ylim = c(0, 0.8),
  pos = "bottomright",
  main = "Adjusted Mutual Information"
)
mtext(
  "Partitioning Around Medoids clustering performance\nfor different labels\nReMap2020 selected experiments",
  side = 3,
  outer = TRUE,
  line = -1,
  font = 2,
  cex = 1.2
)
```

# Per TF clustering core promoters, static cut, majority voting
DB filtering, at least 10 promoters not all promoters with signal

```{r}
hclustDist <- function(mat, method, cheight, cl_basename) {
  mat <- as.matrix(mat)
  d_mat <- if (method == "pearson") {
    sqrt(1 - cor(mat, method = "pearson")) %>% as.dist()
  } else {
    proxy::dist(x = mat, method = method, by_rows = FALSE)
  }

  hc <- hclust(d_mat, method = "ward.D2")
  cl <- cutree(hc, h = cheight)

  return(cl)
}

nameClusters <- function(cl, cl_basename) {
  vec_names <- names(cl)
  cl <- paste0(cl_basename, "_cl", cl, "_", max(cl))
  reps <- table(cl)
  cl <- paste0(cl, "_R", reps[cl])
  names(cl) <- vec_names

  return(cl)
}

makeClusteredX <- function(cl, X, alpha) {
  stopifnot(all(names(cl) == colnames(X)))

  intmat <- if (is.na(alpha)) {
    intvecs <- lapply(
      X = unique(cl),
      FUN = function(clu)
        Matrix::rowSums(X[, cl == clu, drop = FALSE], sparseResult = TRUE)
    )
    i <- do.call(c, lapply(intvecs, slot, "i"))
    j_lens <- vapply(intvecs, function(v) length(slot(v, "i")), numeric(1L))
    j <- do.call(c, lapply(seq_along(j_lens), function(l) rep(1L, times = j_lens[l]) * l))
    x <- do.call(c, lapply(intvecs, slot, "x"))
    Matrix::sparseMatrix(
      i = i,
      j = j,
      x = x,
      dimnames = list(rownames(X), levels(cl))
    )
  } else {
    do.call(
      what = cbind,
      args = lapply(
        X = unique(cl),
        FUN = function(clu)
          simplifyInteractionMatrix(
            mat = X[, names(cl)[cl == clu], drop = FALSE],
            alpha = alpha,
            colname = clu
          )
      )
    )
  }

  return(intmat)
}
```

## based on core promoters
```{r eval=FALSE}
cut_height <- seq(0.5, 2, by = 0.4) # seq(0.05, 0.21, by = 0.04) #
alphas <- c(NA, 0.3, 0.5)
method <- c("pearson", "Jaccard", "Dice", "Russel", "Tanimoto")
parm_grid <- expand.grid(cheight = cut_height, method = method)

for (db_name in c("remap", "chip_atlas")) {
  db <- get(paste0(db_name, "_promoters_core"))
  j <- (Matrix::colSums(db) >= 10) & (Matrix::colSums(db) != nrow(db))
  db <- db[, j]
  db_meta <- get(paste0(db_name, "_meta"))
  db_meta <- db_meta[id %in% colnames(db), ]
  tfs <- db_meta[, unique(tf)]
  for (i in seq_len(nrow(parm_grid))) {
    static <- c()
    method <- parm_grid[i, "method"]
    cheight <- parm_grid[i, "cheight"]
    print(paste0(cheight, " ", method))

    # per TF clustering
    for (tf_name in tfs) {
      print(tf_name)
      sigid <- db_meta[tf == tf_name, id]
      if (length(sigid) == 1) {
        cl_static <- stats::setNames(paste0(tf_name, "_cl1_1_R1"), sigid)
      } else {
        cl_static <- hclustDist(db[, sigid], method, cheight, tf_name)
        cl_static <- nameClusters(cl_static, tf_name)
      }

      static <- c(static, cl_static)
    }
    cl <- static[colnames(db)]
    meta <- data.table::data.table(id = names(cl), cluster = cl)
    data.table::fwrite(meta,
                       file = paste0("meta_", db_name, "_", method, "_", cheight, ".csv"))


    # all
    for (alpha in alphas) {
      intmat <- get(paste0(db_name, "_promoters"))
      intmat <- intmat[, colnames(db)]
      a <- ifelse(is.na(alpha), "rowsum", alpha)
      out_name <- paste0(db_name, "_promoters_", method, "_", cheight, "_", a)
      intmat <- makeClusteredX(cl, intmat, alpha)
      assign(
        x = out_name,
        value = intmat
      )
      save(list = out_name,
          file = paste0(out_name, ".rda"))
    }
  }
}
```

## Test different clusterings performance in TGFbeta context

```{r eval=FALSE}
load(system.file("inst", "extdata", "TGFbeta_counts_symbol.rda",
                 package = "xcore"))

# Here we look at 24h samples only
# construct sample matrix
samples <- data.frame(
  samples_names = counts_symbol %>% colnames(),
  exp_fac = counts_symbol %>%
    colnames() %>%
    sub(pattern = "_R.", replacement = ""),
  stringsAsFactors = FALSE) %>%
  dplyr::filter(grepl("00|24", samples_names))

# construct design matrix
design_mat <- model.matrix(~ 0 + exp_fac, data = samples)
colnames(design_mat) <- sub( "exp_fac", "" , colnames(design_mat))
rownames(design_mat) <- samples$samples_names

designA <- design_mat[
  grepl("A_", rownames(design_mat)),
  grepl("A_", colnames(design_mat)),
  drop = FALSE
  ]

symbol2dpi <- stats::setNames(promoters_f5_core$name, promoters_f5_core$SYMBOL)

mat <- counts_dpi[, grep("A_.*(00|24)", colnames(counts_dpi))]
base_lvl <- "A_TGFb_00h"
dataA_dpi <- prepareCountsForRegression(
  counts = mat,
  base_lvl = base_lvl,
  design = designA,
  log2 = TRUE,
  pseudo_count = 1L)
```

# Load signatures

```{r eval=FALSE}
collapsed_sig_names <- list.files(pattern = "remap_promoters.*rda$") %>%
  sub(pattern = "\\.rda", replacement = "")
collapsed_sig_files <- list.files(pattern = "remap_promoters.*rda$", full.names = TRUE)
for (sig in collapsed_sig_files) load(sig)

# hot fix
for (sig in collapsed_sig_names) {
  s <- get(sig)
  if (is.null(colnames(s))) {
    colnames(s) <- colnames(get(sub("_rowsum", "_0.3",  sig)))
    assign(x=sig, value=s)
  }
}
```

# Combine expression with signatures

```{r eval=FALSE}
signatures_to_add <- lapply(collapsed_sig_names, get)
names(signatures_to_add) <- collapsed_sig_names
signatures_to_add[["remap"]] <- remap_promoters

# A-549
signatures_to_add[["mae"]] <- dataA_dpi
dataA_dpi <- do.call(addSignatures, signatures_to_add)
dataA_dpi <- filterSignatures(dataA_dpi)

for (sig in collapsed_sig_names) {rm(list = sig)}
rm(signatures_to_add)
gc()
```

## Ridge regression

```{r eval=FALSE}
regression <- list(A_549 = list())

# A-549
## DPI
xnames <- setdiff(names(dataA_dpi), c("U", "Y"))
regression[["A_549"]][["DPI"]] <- modelGeneExpression(
  mae = dataA_dpi,
  yname = "Y",
  uname = "U",
  xnames = xnames,
  pvalues = FALSE,
  precalcmodels = regression[["A_549"]][["DPI"]][["regression_models"]]
  )
save(regression, file = "regression.rda")
```

```{r}
load("regression.rda")
```

# R2
## A-549 24h
```{r eval=FALSE}
doMC::registerDoMC(1L)
xnames <- setdiff(names(dataA_dpi), c("U", "Y"))
rsqA <- foreach(nm = xnames, .inorder = TRUE, .final = function(x) setNames(x, xnames)) %:%
  foreach(i = seq_len(4L), .combine = c) %dopar%
    estimateStat(
      x = dataA_dpi[[nm]],
      y = dataA_dpi[["Y"]][, i],
      u = dataA_dpi[["U"]],
      s = regression[["A_549"]][["DPI"]][["regression_models"]][[nm]][[i]]$lambda.min,
      nfold = 5,
      statistic = rsq)
save(rsqA, file = "rsqA.rda")
```

```{r}
load("rsqA.rda")
```

```{r}
library(ggplot2)

rsqA_df <- lapply(
  X = setdiff(names(rsqA), "remap"),
  FUN = function(nm) {
    x <- sub(pattern = "remap_promoters_", replacement = "", x = nm) %>%
      stringr::str_split(pattern = "_", n = 3) %>%
      unlist()
    data.frame(
      distance = x[1],
      cutoff = as.numeric(x[2]),
      collapsing = x[3],
      mean = mean(rsqA[[nm]]),
      stringsAsFactors = FALSE
    )
  }) %>%
  do.call(what = rbind)

ggplot(
  data = rsqA_df,
  aes(
    x = cutoff,
    y = mean,
    color = distance,
    linetype = collapsing
  )
) +
  geom_line() +
  geom_hline(yintercept = mean(rsqA[["remap"]]), linetype = "dashed") +
  xlab("Clustering cut-off") +
  ylab(expression(R ^ 2)) +
  ggtitle("Comparison of different signatures clustering approaches")

ggplot(
  data = rsqA_df[rsqA_df$distance == "pearson", ],
  aes(
    x = cutoff,
    y = mean,
    color = distance,
    linetype = collapsing
  )
) +
  geom_line() +
  geom_hline(yintercept = mean(rsqA[["remap"]]), linetype = "dashed") +
  xlab("Clustering cut-off") +
  ylab(expression(R ^ 2)) +

  ggtitle("Comparison of different signatures clustering approaches\nPearson distance")
```
