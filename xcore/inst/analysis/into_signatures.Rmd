---
title: "Deeper look into the 'signatures'"
author: "Maciej Migdał"
output: pdf_document
---

```{r include=FALSE}
devtools::load_all()
library(data.table)

# Internally used functions

# Function return logical vector indicating columns populated in all rows
# mat - object of class dgCMatrix with only 1 and 0 values
getSharedColumns <- function(mat) {
    stopifnot(is(mat, "dgCMatrix"))
    stopifnot(nrow(mat) > 0)

    Matrix::colSums(mat) == nrow(mat)
}

# Funtion return features from subject overlapped by query
# where subject, query are GRanges objects
# ... other arguments internally passed to GenomicRanges::findOverlaps
intersectGr <- function(subject, query, ...) {
    stopifnot(is(subject, "GRanges"))
    stopifnot(is(query, "GRanges"))

    hits <- GenomicRanges::findOverlaps(query = query, subject = subject, ...)
    i <- S4Vectors::subjectHits(hits)
    subject[i, ]
}

# Function returns all pairs of values in a vector; order in pair is not
# considered relevant
# x character vector of length > 1
getSharedColumnsPairs <- function(mat) {
    stopifnot(is(mat, "dgCMatrix"))
    stopifnot(nrow(mat) > 0)
    
    indexes <- combn(x = seq(from = 1, to = nrow(mat)), 
                     m = 2,
                     simplify = FALSE)
    vapply(X = indexes, 
           function(i) sum(Matrix::colSums(mat[i, ]) == 2), 
           FUN.VALUE = integer(1L))
}

# Function return summary as a string
summaryString <- function(...) {
    s <- summary(...)
    snm <- names(s)
    sval <- s %>% round(2) %>% as.character()
    len <- vapply(X = seq_along(snm), 
                  FUN = function(i) max(nchar(c(snm[i], sval[i]))) + 3L, 
                  FUN.VALUE = integer(1L))
    snm <- paste(vapply(
        X = seq_along(snm),
        FUN = function(i) stringr::str_pad(snm[i], len[i]),
        FUN.VALUE = character(1L)
        ), collapse = " ")
    sval <- paste(vapply(
        X = seq_along(sval),
        FUN = function(i) stringr::str_pad(sval[i], len[i] + 2),
        FUN.VALUE = character(1L)
        ), collapse = " ")
    paste0(snm, "\n", sval)
}

# Function calculates TF or Context coverage based on interaction matrix
# col to use for grouping
getCoverage <- function(mat, col = c(2, 3), sep = ".") {
    colnm <- colnames(mat) %>% 
        gsub(pattern = paste0("(.*)\\", sep, "(.*)\\", sep, "(.*)"),
             replacement = paste0("\\", col))
    DelayedArray::colsum(x = mat, group = colnm %>% as.factor()) %>%
        `>`(1) %>%
        rowSums()
}

# Function plot coverage histogram
coverageHist<- function(x, breaks = 40, cex = 0.7, ...) {
    par(mar = c(5, 5, 6, 2))
    graphics::hist(x = x, 
                   breaks = breaks,
                   cex = 0.7,
                   ...)
    mtext(text = summaryString(x), 
          side = 3,
          cex=0.6)
}

# Function plot two group box plot
blacklistBoxPlot <- function(coverage, cov_names, gr1, aname, bname, ...) {
    blk <- coverage[cov_names %in% gr1]
    nonblk <- coverage[! cov_names %in% gr1]
    aname <- paste0(aname, " (%i)")
    bname <- paste0(bname, " (%i)")

    graphics::boxplot(blk, nonblk,
                      names = c(sprintf(aname, length(blk)), 
                                sprintf(bname, length(nonblk))),
                      ...)
}

# Internally used datasets
# ENCODE blacklist list 636 regions spanning ~7% of human genome
blacklist <- rtracklayer::import(system.file("inst",
                                             "extdata",
                                             "hg38-blacklist.v2.bed.gz",
                                             package = "xcore")) %>%
    intersectGr(subject = promoters_f5, type = "any") %>%
    GenomicRanges::mcols() %>%
    `[[`("name")
    

# ENSEMBL soft mask list 4725854 regions spanning ~50% of human genome
ensembl_sm <- rtracklayer::import(system.file("inst",
                                              "extdata",
                                              "hg38_ensembl_sm.bed.gz",
                                              package = "xcore")) %>%
    intersectGr(subject = promoters_f5, type = "any") %>%
    GenomicRanges::mcols() %>%
    `[[`("name")

# Protein atlas
protein_atlas <-
    data.table::fread(
        file = system.file("inst", "extdata", "proteinatlas.tsv.gz", package = "xcore"),
        header = TRUE
    )

# FANTOM5 promoter expression table
# Matrix of promoters normalized expression across datasets in FANTOM5, 
# column names are not imported!
promoters_f5_expression <-
    data.table::fread(
        file = system.file("inst",
                           "extdata",
                           "hg38_fair+new_CAGE_peaks_phase1and2_tpm.osc.txt.gz",
                           package = "xcore"),
        header = TRUE
    )
promoters_f5_expression <-
    data.table::melt(data = promoters_f5_expression,
                     id.vars = "00Annotation")[, .(
                                               mean = mean(value, na.rm = TRUE),
                                               min = min(value, na.rm = TRUE),
                                               max = max(value, na.rm = TRUE),
                                               sd = sd(value, na.rm = TRUE)
                                               ),
                                               by = "00Annotation"
                     ]

gc()
```
# Deeper look into the “signatures”

## Technical biases and noise vs biological signal.

Based on the Bogumil's observation that some promoters always give a signal
regardless on the transcription factor we look at. As well as, some TF gives 
signal regardless of the promoter we look at. We set out with an exploratory 
data analysis on the ReMap2020 and ChIP-Atlas data sets.

ReMap2020 and ChIP-Atlas were intersected with FANTOM5 promoters into 
interaction matrices with ChIP-seq experiment as a columns and promoters as a
row names. Overall our data included `r nrow(remap_promoters)` promoters and
`r ncol(remap_promoters)`, `r ncol(chip_atlas_promoters)` ChIP-seq experiments
for ReMap2020, ChIP-Atlas respectively.

To look deeper into those data sets, first we have limited our analysis to 
core promoters defined as promoters associated with a protein coding gene (as
per GENCODE 38) and supported by ENCODE ROADMAP data. Finally, we select one
promoter per associated gene that have maximum FANTOM5 score.
   
```{r core_promoters}
# only protein coding genes as per GENCODE annotation
promoters_f5_core <- 
    promoters_f5[promoters_f5$gene_type_gencode == "protein_coding", ]

# ENCODE ROADMAP confirmation
roadmap_promoters <- rtracklayer::import.bed(
    con = system.file(
        "inst",
        "extdata",
        "Epigenome5DRoadmapDHS_promoter_hg38_liftOver.bed",
        package = "xcore"
    )
)
GenomeInfoDb::seqlevels(roadmap_promoters, pruning.mode = "coarse") <-
    GenomeInfoDb::seqlevels(promoters_f5_core)
promoters_f5_core <- intersectGr(promoters_f5_core, roadmap_promoters)

# Select best promoter per gene
best_promoters <- GenomicRanges::mcols(promoters_f5_core) %>%
    as.data.frame() %>%
    dplyr::group_by(SYMBOL) %>%
    dplyr::slice(which.max(score)) %>%
    dplyr::pull(name)
promoters_f5_core <-
    promoters_f5_core[promoters_f5_core$name %in% best_promoters, ]

# restrict interaction matrices to core promoters only
remap_promoters_core <- remap_promoters[promoters_f5_core$name, ]
chip_atlas_promoters_core <- chip_atlas_promoters[promoters_f5_core$name, ]
```

This give us an interaction matrix with `r nrow(remap_promoters_core)` promoters
(rows) and `r ncol(remap_promoters_core)`, `r ncol(chip_atlas_promoters_core` 
ChIP-seq experiments (columns) for ReMap2020, ChIP-Atlas respectively.

### Looking at promoter TF interaction matrix row wise (promoter wise)

#### Promoter coverage

For each promoter we calculate coverage which is equal to the number
of ChIP-seq experiment the promoter intersect with. Additionally we calculate 
the TF coverage equal to the number of ChIP-seq for different TF promoter 
intersect with. And biological context coverage which is equal to the number of
different biological contexts (eg. tissue, cell) promoter intersect with. 

<!-- TODO experiment coverage -->

```{r promoters_coverage}
promoters <- list(
    remap = data.table::data.table(
        nm = remap_promoters_core %>% rownames(),
        coverage = remap_promoters_core %>% Matrix::rowSums(),
        tf_coverage = remap_promoters_core %>% getCoverage(col = 2, sep = "."),
        con_coverage = remap_promoters_core %>% getCoverage(col = 3, sep = ".")
    ),
    chip_atlas = data.table::data.table(
        nm = chip_atlas_promoters_core %>% rownames(),
        coverage = chip_atlas_promoters_core %>% Matrix::rowSums(),
        tf_coverage = chip_atlas_promoters_core %>%
            getCoverage(col = 1, sep = "_"),
        con_coverage = chip_atlas_promoters_core %>%
            getCoverage(col = 2, sep = "_")
    )
)

# Promoter coverage histogram
par(mfrow = c(1, 2), cex = 0.7, pty = "s")
coverageHist(x = promoters[["remap"]][["coverage"]],
             main = "ReMap2020 promoter coverage")
coverageHist(x = promoters[["chip_atlas"]][["coverage"]], 
             main = "ChIP-Atlas promoter coverage")

# Promoter TF coverage histogram
par(mfrow = c(1, 2), cex = 0.7, pty = "s")
coverageHist(x = promoters[["remap"]][["tf_coverage"]],
             main = "ReMap2020 promoter TF coverage")
coverageHist(x = promoters[["chip_atlas"]][["tf_coverage"]], 
             main = "ChIP-Atlas promoter TF coverage")

# Promoter biological context coverage histogram
par(mfrow = c(1, 2), cex = 0.7, pty = "s")
coverageHist(x = promoters[["remap"]][["con_coverage"]],
             main = "ReMap2020 promoter context coverage")
coverageHist(x = promoters[["chip_atlas"]][["con_coverage"]], 
             main = "ChIP-Atlas promoter context coverage")
```

For some promoters we can observe no coverage at all 
`r sum(promoters[["remap"]][["coverage"]] == 0)`,
`r sum(promoters[["chip_atlas"]][["coverage"]] == 0)`
for ReMap2020, ChIP-Atlas.

#### ENCODE blacklist

We investigate differences in promoters coverage by overlapping the promoters
with ENCODE's list of blacklisted regions.

```{r blacklisted_promoters}
par(mfrow = c(1, 2), cex = 0.7, pty = "s")
blacklistBoxPlot(coverage = promoters[["remap"]][["coverage"]],
                 cov_names = promoters[["remap"]][["nm"]],
                 gr1 = blacklist,
                 aname = "blacklisted",
                 bname = "other",
                 main = "ReMap2020\nENCODE blacklisted regions",
                 ylab = "promoter coverage")
blacklistBoxPlot(coverage = promoters[["chip_atlas"]][["coverage"]],
                 cov_names = promoters[["chip_atlas"]][["nm"]],
                 gr1 = blacklist,
                 aname = "blacklisted",
                 bname = "other",
                 main = "ChIP-Atlas\nENCODE blacklisted regions",
                 ylab = "promoter coverage")
```

#### Ensembl soft masked regions

We investigate differences in promoters coverage by overlapping the promoters
with Ensembl's list of soft masked regions.

```{r}
par(mfrow = c(1, 2), cex = 0.7, pty = "s")
blacklistBoxPlot(coverage = promoters[["remap"]][["coverage"]],
                 cov_names = promoters[["remap"]][["nm"]],
                 gr1 = ensembl_sm,
                 aname = "soft masked",
                 bname = "other",
                 main = "ReMap2020\nEnsembl soft masked regions",
                 ylab = "promoter coverage")
blacklistBoxPlot(coverage = promoters[["chip_atlas"]][["coverage"]],
                 cov_names = promoters[["chip_atlas"]][["nm"]],
                 gr1 = ensembl_sm,
                 aname = "soft masked",
                 bname = "other",
                 main = "ChIP-Atlas\nEnsembl soft masked regions",
                 ylab = "promoter coverage")
```

# Promoters coverage vs length
graphics::smoothScatter(
     x = remap_promoters_counts,
     y = GenomicRanges::width(promoters_f5_core),
     main = sprintf("ReMap2020 promoters coverage vs length\nPearson: %f",
                    cor(x = remap_promoters_counts,
                        y = GenomicRanges::width(promoters_f5_core),
                        method = "pearson")),
     xlab = "promoter coverage",
     ylab = "promoter length")

# Promoters coverage vs score
graphics::smoothScatter(
     x = remap_promoters_counts,
     y = log10(promoters_f5_core$score),
     main = sprintf("ReMap2020 promoters coverage vs score\nPearson: %f",
                    cor(x = remap_promoters_counts,
                        y = log10(promoters_f5_core$score),
                        method = "pearson")),
     xlab = "promoter counts",
     ylab = "log10(promoter score)")

# Promoters score vs length
graphics::smoothScatter(
     x = log10(promoters_f5_core$score),
     y = GenomicRanges::width(promoters_f5_core),
     main = sprintf("ReMap2020 promoters coverage vs score\nPearson: %f",
                    cor(x = log10(promoters_f5_core$score),
                        y = GenomicRanges::width(promoters_f5_core),
                        method = "pearson")),
     xlab = "log10(promoter score)",
     ylab = "promoter length")

# Protein Atlas gene specificity classification
# Category 	Description
# Enriched 	NX level in a particular tissue/region/cell type at least four times any other tissue/region/cell type
# Group enriched 	NX levels of a group (of 2-5 tissues or 2-10 cell types or 2-5 brain regions) at least four times any other tissue/region/cell type
# Enhanced 	NX levels of a group (of 1-5 tissues or 1-10 cell types or 1-5 brain regions) at least four times the mean of other tissue/region/cell types
# Low specificity 	NX >= 1 in at least one tissue/region/cell type but not elevated in any tissue/region/cell type
# Not detected 	NX < 1 in all tissue/cell/region types
promoters_meta <- GenomicRanges::mcols(promoters_f5_core) %>%
    as.data.frame() %>%
    dplyr::left_join(y = protein_atlas[, c("Gene", 
                                           "RNA tissue specificity",
                                           "RNA single cell type specificity")],
                     by = c("SYMBOL" = "Gene"))
promoters_meta$counts <- remap_promoters_counts[promoters_meta$name]
graphics::boxplot(counts ~ `RNA tissue specificity`, 
                  data = promoters_meta,
                  main = "ReMap2020 promoter coverage vs Protein Atlas tissue specificity",
                  cex.axis = 0.7)
graphics::boxplot(counts ~ `RNA single cell type specificity`, 
                  data = promoters_meta,
                  main = "ReMap2020 promoter coverage vs Protein Atlas single cell type specificity",
                  cex.axis = 0.5)

# shared_pairs_remap <- lapply(
#     X = 1:100, 
#     FUN = function(i) {
#         idx <- sample(x = rownames(remap_promoters_core),
#                       size = 100,
#                       replace = FALSE)
#         getSharedColumnsPairs(remap_promoters_core[idx, ])
#     })

# How does the number of shared TFs depends on how many top promoters we are
# looking at?
shared_tf <- c()
shared_tf_nprom <- c()
x <- seq(from = 1, to = 3322, by = 50)
for (n in x) {
    sel <- remap_promoters_core[remap_promoters_counts >= n, , drop = FALSE]
    shared_tf_nprom <- c(shared_tf_nprom, nrow(sel))
    n_tf <- sel %>%
        getSharedColumns() %>%
        sum()
    shared_tf <- c(shared_tf, n_tf)
}
plot(x = x,
     y = shared_tf,
     main = "ReMap2020 promoters coverage vs number of shared TFs",
     xlab = "promoter coverage >= x",
     ylab = "number of shared TFs")
plot(x = shared_tf_nprom,
     y = shared_tf,
     main = "ReMap2020 number of promoters vs number of shared TFs",
     xlab = "number of promoters",
     ylab = "number of shared TFs")
```

```{r promoters_coverage_chip_atlas}
# TODO set chip_atlas_promoters class to  dgCMatrix
chip_atlas_promoters_core <- as(chip_atlas_promoters_core, "dgCMatrix")

chip_atlas_promoters_counts <- chip_atlas_promoters_core %>%
    Matrix::rowSums()

chip_atlas_promoters_counts %>%
    summary()

chip_atlas_promoters_counts %>%
    graphics::hist(breaks = 100,
                   plot = TRUE,
                   main = "ChIP-Atlas promoter coverage")

(chip_atlas_promoters_counts == 0) %>%
    table() / length(chip_atlas_promoters_counts)

(m <- chip_atlas_promoters_counts == 0) %>% sum()

# What genes are those 0 promoters assigned to?
# TODO comapre zero promoters between remap and chip-atlas
zero_promoters <- names(m)[m]
zero_promoters <- promoters_f5_core[promoters_f5_core$name %in% zero_promoters, ]
zero_promoters$SYMBO
boxplot(log10(promoters_f5_core$score), 
        log10(zero_promoters$score),
        names = c("all", "zero"),
        main = "Zero coverage promoters scores")
(zero_promoters$name %in% blacklist) %>% table()
protein_atlas %>%
    dplyr::filter(Gene %in% zero_promoters$SYMBOL) %>%
    dplyr::pull(`RNA tissue specificity`) %>%
    table()

# Lets look into promoters with the highest number of transcription factors,
# how many of those are shared?
chip_atlas_promoters_highest <-
    chip_atlas_promoters_core[chip_atlas_promoters_counts >= 4500, ]
shared_cols_m <- getSharedColumns(chip_atlas_promoters_highest)
sum(shared_cols_m)
highest_promoters <- chip_atlas_promoters_highest %>% rownames()
highest_promoters <- 
    promoters_f5_core[promoters_f5_core$name %in% highest_promoters, ]
boxplot(log10(promoters_f5_core$score), 
        log10(highest_promoters$score),
        names = c("all", "highest"),
        main = "Highest coverage promoters scores")
(highest_promoters$name %in% blacklist) %>% table()
protein_atlas %>%
    dplyr::filter(Gene %in% highest_promoters$SYMBOL) %>%
    dplyr::pull(`RNA tissue specificity`) %>%
    table()

# How does the number of shared TFs depends on how many top promoters we are
# looking at?
shared_tf <- c()
shared_tf_nprom <- c()
x <- seq(from = 1, to = 5000, by = 50)
for (n in x) {
    sel <-
        chip_atlas_promoters_core[chip_atlas_promoters_counts >= n, , drop = FALSE]
    shared_tf_nprom <- c(shared_tf_nprom, nrow(sel))
    n_tf <- sel %>%
        getSharedColumns() %>%
        sum()
    shared_tf <- c(shared_tf, n_tf)
}
plot(x = x,
     y = shared_tf,
     main = "ChIP-Atlas promoters coverage vs number of shared TFs",
     xlab = "promoter coverage >= x",
     ylab = "number of shared TFs")
plot(x = shared_tf_nprom,
     y = shared_tf,
     main = "ChIP-Atlas number of promoters vs number of shared TFs",
     xlab = "number of promoters",
     ylab = "number of shared TFs")

# Blacklisted promoters vs TFs coverage
blk <- chip_atlas_promoters_counts[
        names(chip_atlas_promoters_counts) %in% blacklist]
length(blk)
nonblk <- chip_atlas_promoters_counts[
        ! names(chip_atlas_promoters_counts) %in% blacklist]
graphics::boxplot(blk,
                  nonblk,
                  main = "Blacklisted regions vs TF count",
                  names = c(
                      sprintf("blacklisted (%i)", length(blk)), 
                      sprintf("non blacklisted (%i)", length(nonblk)))
)

# Ensembl soft masked promoters vs TFs coverage
sm <- chip_atlas_promoters_counts[
        names(chip_atlas_promoters_counts) %in% ensembl_sm]
length(sm)
nonsm <- chip_atlas_promoters_counts[
        ! names(chip_atlas_promoters_counts) %in% ensembl_sm]
graphics::boxplot(sm,
                  nonsm,
                  main = "Ensembl soft masked regions vs TF count",
                  names = c(
                      sprintf("soft masked (%i)", length(sm)), 
                      sprintf("non soft masked (%i)", length(nonsm)))
)

# Promoters coverage vs length
graphics::smoothScatter(
     x = chip_atlas_promoters_counts,
     y = GenomicRanges::width(promoters_f5_core),
     main = sprintf("ChIP-Atlas promoters coverage vs length\nPearson: %f",
                    cor(x = chip_atlas_promoters_counts,
                        y = GenomicRanges::width(promoters_f5_core),
                        method = "pearson")),
     xlab = "promoter coverage",
     ylab = "promoter length")

# Promoters coverage vs score
graphics::smoothScatter(
     x = chip_atlas_promoters_counts,
     y = log10(promoters_f5_core$score),
     main = sprintf("ChIP-Atlas promoters coverage vs score\nPearson: %f",
                    cor(x = chip_atlas_promoters_counts,
                        y = log10(promoters_f5_core$score),
                        method = "pearson")),
     xlab = "promoter counts",
     ylab = "log10(promoter score)")

# Promoters score vs length
graphics::smoothScatter(
     x = log10(promoters_f5_core$score),
     y = GenomicRanges::width(promoters_f5_core),
     main = sprintf("ChIP-Atlas promoters coverage vs score\nPearson: %f",
                    cor(x = log10(promoters_f5_core$score),
                        y = GenomicRanges::width(promoters_f5_core),
                        method = "pearson")),
     xlab = "log10(promoter score)",
     ylab = "promoter length")

# Protein Atlas gene specificity classification
# Category 	Description
# Enriched 	NX level in a particular tissue/region/cell type at least four times any other tissue/region/cell type
# Group enriched 	NX levels of a group (of 2-5 tissues or 2-10 cell types or 2-5 brain regions) at least four times any other tissue/region/cell type
# Enhanced 	NX levels of a group (of 1-5 tissues or 1-10 cell types or 1-5 brain regions) at least four times the mean of other tissue/region/cell types
# Low specificity 	NX >= 1 in at least one tissue/region/cell type but not elevated in any tissue/region/cell type
# Not detected 	NX < 1 in all tissue/cell/region types

protein_atlas <-
    data.table::fread(
        file = system.file("inst", "extdata", "proteinatlas.tsv.gz", package = "xcore"),
        header = TRUE
    )
promoters_meta <- GenomicRanges::mcols(promoters_f5_core) %>%
    as.data.frame() %>%
    dplyr::left_join(y = protein_atlas[, c("Gene", 
                                           "RNA tissue specificity",
                                           "RNA single cell type specificity")],
                     by = c("SYMBOL" = "Gene"))
promoters_meta$counts <- chip_atlas_promoters_counts[promoters_meta$name]
graphics::boxplot(counts ~ `RNA tissue specificity`, 
                  data = promoters_meta,
                  main = "ChIP-Atlas promoter coverage vs Protein Atlas tissue specificity",
                  cex.axis = 0.7)
graphics::boxplot(counts ~ `RNA single cell type specificity`, 
                  data = promoters_meta,
                  main = "ChIP-Atlas promoter coverage vs Protein Atlas single cell type specificity",
                  cex.axis = 0.5)
```

### Looking at promoter TF interaction matrix column wise (TF wise)

```{r tf_coverage_remap}
remap_tf_counts <- remap_promoters_core %>%
    Matrix::colSums()

remap_tf_counts %>%
    summary()

remap_tf_counts %>%
    `/`(nrow(remap_promoters_core)) %>%
    summary()

remap_tf_counts %>%
    graphics::hist(breaks = 100,
                   plot = TRUE,
                   main = "ReMap2020 TFs coverage")

# ZERO TFs
(remap_tf_counts == 0) %>% table() / length(remap_tf_counts)
(m <- remap_tf_counts == 0) %>% sum()
names(m)[m]

# How many TFs overlapp X% or more promoters
vapply(X = seq(from = 0, to = 1, by = 0.1),
       FUN = function(x) sum(remap_tf_counts >= (nrow(remap_promoters_core) * x)),
       FUN.VALUE = numeric(1L)) %>%
    stats::setNames(nm = seq(from = 0, to = 100, by = 10))
# what are the top TFs?
remap_tf_counts %>%
    sort(decreasing = TRUE) %>%
    as.data.frame() %>%
    head(30)
```

```{r tf_coverage_chip_atlas}
chip_atlas_tf_counts <- chip_atlas_promoters_core %>%
    Matrix::colSums()

chip_atlas_tf_counts %>%
    summary()

chip_atlas_tf_counts %>%
    `/`(nrow(chip_atlas_promoters_core)) %>%
    summary()

chip_atlas_tf_counts %>%
    graphics::hist(breaks = 100,
                   plot = TRUE,
                   main = "ChIP-Atlas TFs coverage")

(chip_atlas_tf_counts == 0) %>% table() / length(chip_atlas_tf_counts)
(m <- chip_atlas_tf_counts == 0) %>% sum()

# How many TFs overlapp X% or more promoters
vapply(X = seq(from = 0, to = 1, by = 0.1),
       FUN = function(x) {
           sum(chip_atlas_tf_counts >= (nrow(chip_atlas_promoters_core) * x))
       },
       FUN.VALUE = numeric(1L)) %>%
    stats::setNames(nm = seq(from = 0, to = 100, by = 10))
# what are the top TFs?
chip_atlas_tf_counts %>%
    sort(decreasing = TRUE) %>%
    as.data.frame() %>%
    head(30)
```
