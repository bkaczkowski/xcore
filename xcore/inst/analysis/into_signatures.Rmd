---
title: "Deeper look into the 'signatures'"
author: "Maciej Migda≈Ç"
output: pdf_document
---

```{r include=FALSE}
knitr::opts_chunk$set(warning = FALSE)

devtools::load_all()
library(data.table)
```

```{r functions_data, cache=TRUE, echo=FALSE, message=FALSE}
# Internally used functions

# Function return logical vector indicating columns populated in all rows
# mat - object of class dgCMatrix with only 1 and 0 values
getSharedColumns <- function(mat) {
    stopifnot(is(mat, "dgCMatrix"))
    stopifnot(nrow(mat) > 0)

    Matrix::colSums(mat) == nrow(mat)
}

# Funtion return features from subject overlapped by query
# where subject, query are GRanges objects
# ... other arguments internally passed to GenomicRanges::findOverlaps
intersectGr <- function(subject, query, ...) {
    stopifnot(is(subject, "GRanges"))
    stopifnot(is(query, "GRanges"))

    hits <- GenomicRanges::findOverlaps(query = query, subject = subject, ...)
    i <- S4Vectors::subjectHits(hits)
    subject[i, ]
}

# Function returns all pairs of values in a vector; order in pair is not
# considered relevant
# x character vector of length > 1
getSharedColumnsPairs <- function(mat) {
    stopifnot(is(mat, "dgCMatrix"))
    stopifnot(nrow(mat) > 0)
    
    indexes <- combn(x = seq(from = 1, to = nrow(mat)), 
                     m = 2,
                     simplify = FALSE)
    vapply(X = indexes, 
           function(i) sum(Matrix::colSums(mat[i, ]) == 2), 
           FUN.VALUE = integer(1L))
}

# Function return summary as a string
summaryString <- function(...) {
    s <- summary(...)
    snm <- names(s)
    sval <- s %>% round(2) %>% as.character()
    len <- vapply(X = seq_along(snm), 
                  FUN = function(i) max(nchar(c(snm[i], sval[i]))) + 3L, 
                  FUN.VALUE = integer(1L))
    snm <- paste(vapply(
        X = seq_along(snm),
        FUN = function(i) stringr::str_pad(snm[i], len[i]),
        FUN.VALUE = character(1L)
        ), collapse = " ")
    sval <- paste(vapply(
        X = seq_along(sval),
        FUN = function(i) stringr::str_pad(sval[i], len[i] + 2),
        FUN.VALUE = character(1L)
        ), collapse = " ")
    paste0(snm, "\n", sval)
}

# Function calculates TF or Context coverage based on interaction matrix
# col to use for grouping
getCoverage <- function(mat, col = c(2, 3), sep = "\\.") {
    n <- stringr::str_count(colnames(mat)[1], sep)
    colnm <- colnames(mat) %>% 
        gsub(pattern = paste(c("(.*)", rep(c(sep, "(.*)"), n)), collapse = ""),
             replacement = paste0("\\", col))
    DelayedArray::colsum(x = mat, group = colnm %>% as.factor()) %>%
        `>`(1) %>%
        rowSums()
}

# Function plot coverage histogram
coverageHist<- function(x, breaks = 40, cex = 0.7, xlab = "", ...) {
    par(mar = c(5, 5, 6, 2))
    graphics::hist(x = x, 
                   breaks = breaks,
                   cex = 0.7,
                   xlab = xlab,
                   ...)
    mtext(text = summaryString(x), 
          side = 3,
          cex=0.6)
}

# Function plot two group box plot
blacklistBoxPlot <- function(coverage, cov_names, gr1, aname, bname, ...) {
    blk <- coverage[cov_names %in% gr1]
    nonblk <- coverage[! cov_names %in% gr1]
    aname <- paste0(aname, " (%i)")
    bname <- paste0(bname, " (%i)")

    graphics::boxplot(blk, nonblk,
                      names = c(sprintf(aname, length(blk)), 
                                sprintf(bname, length(nonblk))),
                      ...)
}

# Internally used datasets
# ENCODE blacklist list 636 regions spanning ~7% of human genome
blacklist <- rtracklayer::import(system.file("inst",
                                             "extdata",
                                             "hg38-blacklist.v2.bed.gz",
                                             package = "xcore")) %>%
    intersectGr(subject = c(xcore::promoters_f5, xcore::enhancers), 
                type = "any") %>%
    GenomicRanges::mcols() %>%
    `[[`("name")
    

# ENSEMBL soft mask list 4725854 regions spanning ~50% of human genome
ensembl_sm <- rtracklayer::import(system.file("inst",
                                              "extdata",
                                              "hg38_ensembl_sm.bed.gz",
                                              package = "xcore")) %>%
    intersectGr(subject = c(xcore::promoters_f5, xcore::enhancers), 
                type = "any") %>%
    GenomicRanges::mcols() %>%
    `[[`("name")

# Protein atlas
protein_atlas <-
    data.table::fread(
        file = system.file("inst", "extdata", "proteinatlas.tsv.gz", package = "xcore"),
        header = TRUE
    )[! duplicated(Gene), ]

# FANTOM5 promoter expression table
# Matrix of promoters normalized expression across datasets in FANTOM5, 
# column names are not imported!
promoters_f5_expression <-
    data.table::fread(
        file = system.file("inst",
                           "extdata",
                           "hg38_fair+new_CAGE_peaks_phase1and2_tpm.osc.txt.gz",
                           package = "xcore"),
        header = TRUE
    )

# tau calculation from on https://academic.oup.com/bib/article/18/2/205/2562739
#Function require a vector with expression of one gene in different tissues.
#If expression for one tissue is not known, gene specificity for this gene is NA
#Minimum 2 tissues
fTau <- function(x)
{
	if(all(!is.na(x)))
 	{
 		if(min(x, na.rm=TRUE) >= 0)
		{
 			if(max(x)!=0)
 			{
 				x <- (1-(x/max(x)))
 				res <- sum(x, na.rm=TRUE)
 				res <- res/(length(x)-1)
 			} else {
 				res <- 0
 			}
 		} else {
 		res <- NA
 		#print("Expression values have to be positive!")
 		} 
 	} else {
 		res <- NA
 		#print("No data for this gene avalable.")
 	} 
 	return(res)
}

#Hg entropy calculation from on https://academic.oup.com/bib/article/18/2/205/2562739
#Function require a vector with expression of one gene in different tissues.
#If expression for one tissue is not known, gene specificity for this gene is NA
fHg <- function(x)
{	
	if(all(!is.na(x)))
 	{
 		if(min(x, na.rm=TRUE) >= 0)
		{
 			if(sum(x) !=0)
 			{
 				p <- x / sum(x)
 				res <- -sum(p*log2(p), na.rm=TRUE)
 				res <- 1 - (res/log2(length(p))) #Modification: To bring to normalized scale
 			} else {
 				res <- 0
 			} 		
 		} else {
 		res <- NA
 		#print("Expression values have to be positive!")
 		}
 	} else {
 		res <- NA
 		#print("No data for this gene avalable.")
 	}
 	return(res)
}

promoters_f5_expression <-
    data.table::melt(data = promoters_f5_expression,
                     id.vars = "00Annotation")
promoters_f5_expression <- promoters_f5_expression[, .(
                         mean = mean(value, na.rm = TRUE),
                         min = min(value, na.rm = TRUE),
                         max = max(value, na.rm = TRUE),
                         sd = sd(value, na.rm = TRUE),
                         tau = fTau(log(value + 1)),
                         hg = fHg(log(value + 1)),
                         count = sum(value > 0.2)
                     ),
                     by = "00Annotation"]

# enhancers expression
enhancers_f5_expression <-
    data.table::fread(
        file = system.file("inst",
                           "extdata",
                           "F5.hg38.enhancers.expression.tpm.matrix.gz",
                           package = "xcore"),
        header = TRUE
    )

enhancers_f5_expression <-
    data.table::melt(data = enhancers_f5_expression,
                     id.vars = "V1")
enhancers_f5_expression <- enhancers_f5_expression[, .(
                         mean = mean(value, na.rm = TRUE),
                         min = min(value, na.rm = TRUE),
                         max = max(value, na.rm = TRUE),
                         sd = sd(value, na.rm = TRUE),
                         tau = fTau(log(value + 1)),
                         hg = fHg(log(value + 1)),
                         count = sum(value > 0.2)
                     ),
                     by = "V1"]

gc()
```
# Technical biases and noise vs biological signal.

Based on the Bogumil's observation that some promoters always give a signal
regardless on the transcription factor we look at. As well as, some TF gives 
signal regardless of the promoter we look at. We set out with an exploratory 
data analysis on the ReMap2020 and ChIP-Atlas data sets.

## Looking at promoter TF interaction matrix row wise (promoter wise)

ReMap2020 and ChIP-Atlas were intersected with FANTOM5 promoters into 
interaction matrices with ChIP-seq experiment as a columns and promoters as a
row names. Overall our data included `r nrow(remap_promoters)` promoters and
`r ncol(remap_promoters)`, `r ncol(chip_atlas_promoters)` ChIP-seq experiments
for ReMap2020, ChIP-Atlas respectively.

To look deeper into those data sets, first we have limited our analysis to 
core promoters defined as promoters associated with a protein coding gene (as
per GENCODE 38) and supported by ENCODE ROADMAP data. Finally, we select one
promoter per associated gene that have maximum FANTOM5 score.
   
```{r core_promoters}
# only protein coding genes as per GENCODE annotation
promoters_f5_core <- 
    promoters_f5[promoters_f5$gene_type_gencode == "protein_coding", ]

# ENCODE ROADMAP confirmation
roadmap_promoters <- rtracklayer::import.bed(
    con = system.file(
        "inst",
        "extdata",
        "Epigenome5DRoadmapDHS_promoter_hg38_liftOver.bed",
        package = "xcore"
    )
)
GenomeInfoDb::seqlevels(roadmap_promoters, pruning.mode = "coarse") <-
    GenomeInfoDb::seqlevels(promoters_f5_core)
promoters_f5_core <- intersectGr(promoters_f5_core, roadmap_promoters)

# Select best promoter per gene
best_promoters <- GenomicRanges::mcols(promoters_f5_core) %>%
    as.data.frame() %>%
    dplyr::group_by(SYMBOL) %>%
    dplyr::slice(which.max(score)) %>%
    dplyr::pull(name)
promoters_f5_core <-
    promoters_f5_core[promoters_f5_core$name %in% best_promoters, ]

# restrict interaction matrices to core promoters only
remap_promoters_core <- remap_promoters[promoters_f5_core$name, ]
chip_atlas_promoters_core <- chip_atlas_promoters[promoters_f5_core$name, ]
```

This give us an interaction matrix with `r nrow(remap_promoters_core)` promoters
(rows) and `r ncol(remap_promoters_core)`, `r ncol(chip_atlas_promoters_core)` 
ChIP-seq experiments (columns) for ReMap2020, ChIP-Atlas respectively.

### Promoter coverage

For each promoter we calculate coverage which is equal to the number
of ChIP-seq experiment the promoter intersect with. Additionally we calculate 
the TF coverage equal to the number of different TFs the promoter intersect 
with. And biological context coverage which is equal to the number of different 
biological contexts (eg. tissue, cell) promoter intersect with. 

<!-- TODO experiment coverage -->

```{r promoters_coverage}
chip_atlas_promoters_core <- as(chip_atlas_promoters_core, "dgCMatrix")
promoters <- list(
    remap = data.table::data.table(
        nm = remap_promoters_core %>% rownames(),
        coverage = remap_promoters_core %>% Matrix::rowSums(),
        tf_coverage = remap_promoters_core %>% getCoverage(col = 2, sep = "\\."),
        con_coverage = remap_promoters_core %>% getCoverage(col = 3, sep = "\\.")
    ),
    chip_atlas = data.table::data.table(
        nm = chip_atlas_promoters_core %>% rownames(),
        coverage = chip_atlas_promoters_core %>% Matrix::rowSums(),
        tf_coverage = chip_atlas_promoters_core %>%
            getCoverage(col = 1, sep = "_"),
        con_coverage = chip_atlas_promoters_core %>%
            getCoverage(col = 3, sep = "_")
    )
)
```

```{r promoters_coverage_hist}
# Promoter coverage histogram
par(mfrow = c(1, 2), cex = 0.7, pty = "s")
coverageHist(x = promoters[["remap"]][["coverage"]],
             main = "ReMap2020 promoter coverage")
coverageHist(x = promoters[["chip_atlas"]][["coverage"]], 
             main = "ChIP-Atlas promoter coverage")

# Promoter TF coverage histogram
par(mfrow = c(1, 2), cex = 0.7, pty = "s")
coverageHist(x = promoters[["remap"]][["tf_coverage"]],
             main = "ReMap2020 promoter TF coverage")
coverageHist(x = promoters[["chip_atlas"]][["tf_coverage"]], 
             main = "ChIP-Atlas promoter TF coverage")

# Promoter biological context coverage histogram
par(mfrow = c(1, 2), cex = 0.7, pty = "s")
coverageHist(x = promoters[["remap"]][["con_coverage"]],
             main = "ReMap2020 promoter context coverage")
coverageHist(x = promoters[["chip_atlas"]][["con_coverage"]], 
             main = "ChIP-Atlas promoter context coverage")
```

For some promoters we observe no coverage at all:
`r sum(promoters[["remap"]][["coverage"]] == 0)`,
`r sum(promoters[["chip_atlas"]][["coverage"]] == 0)`
for ReMap2020, ChIP-Atlas respectively.

### ENCODE blacklist

We investigate promoters coverage by overlapping the promoters with ENCODE's 
list of blacklisted regions.

>  ENCODE blacklist is a comprehensive set of regions in the human and other 
genomes that have anomalous, unstructured, or high signal in next-generation 
sequencing experiments independent of cell line or experiment. The removal of 
the ENCODE blacklist is an essential quality measure when analyzing functional 
genomics data.
[ENCODE blacklist](https://github.com/Boyle-Lab/Blacklist)

```{r blacklisted_promoters}
par(mfrow = c(1, 2), cex = 0.7, pty = "s")
blacklistBoxPlot(coverage = promoters[["remap"]][["coverage"]],
                 cov_names = promoters[["remap"]][["nm"]],
                 gr1 = blacklist,
                 aname = "blacklisted",
                 bname = "other",
                 main = "ReMap2020\nENCODE blacklisted regions",
                 ylab = "promoter coverage")
blacklistBoxPlot(coverage = promoters[["chip_atlas"]][["coverage"]],
                 cov_names = promoters[["chip_atlas"]][["nm"]],
                 gr1 = blacklist,
                 aname = "blacklisted",
                 bname = "other",
                 main = "ChIP-Atlas\nENCODE blacklisted regions",
                 ylab = "promoter coverage")
```

### Ensembl soft masked regions

We investigate promoters coverage by overlapping the promoters with Ensembl's 
list of soft masked regions.

> Repetitive sequence is found throughout genomes. Ensembl mask repeats using 
Repeat Masker and Dust. 
[assembly repeats](https://www.ensembl.org/info/genome/genebuild/assembly_repeats.html)

```{r soft_masked_promoters}
par(mfrow = c(1, 2), cex = 0.7, pty = "s")
blacklistBoxPlot(coverage = promoters[["remap"]][["coverage"]],
                 cov_names = promoters[["remap"]][["nm"]],
                 gr1 = ensembl_sm,
                 aname = "soft masked",
                 bname = "other",
                 main = "ReMap2020\nEnsembl soft masked regions",
                 ylab = "promoter coverage")
blacklistBoxPlot(coverage = promoters[["chip_atlas"]][["coverage"]],
                 cov_names = promoters[["chip_atlas"]][["nm"]],
                 gr1 = ensembl_sm,
                 aname = "soft masked",
                 bname = "other",
                 main = "ChIP-Atlas\nEnsembl soft masked regions",
                 ylab = "promoter coverage")
```

### Promoters "phisical" properties

We investigate promoters coverage by looking at the relations between promoter
coverage and promoter FANTOM5 score, or width.

```{r promoter_score_length}
stopifnot(all(promoters_f5_core$name == promoters[["remap"]][["nm"]]))
stopifnot(all(promoters_f5_core$name == promoters[["chip_atlas"]][["nm"]]))

promoter_score <- log10(promoters_f5_core$score)
promoter_width <- GenomicRanges::width(promoters_f5_core)

# Promoters coverage vs score
par(mfrow = c(1, 2), cex = 0.7, pty = "s")
graphics::smoothScatter(
     x = promoters[["remap"]][["coverage"]],
     y = promoter_score,
     main = sprintf("ReMap2020\npromoters coverage vs F5 score\nSpearman: %f",
                    cor(x = promoters[["remap"]][["coverage"]],
                        y = promoter_score,
                        method = "spearman")),
     xlab = "promoter coverage",
     ylab = "log10(promoter score)")
graphics::smoothScatter(
     x = promoters[["chip_atlas"]][["coverage"]],
     y = promoter_score,
     main = sprintf("ChIP-Atlas\npromoters coverage vs F5 score\nSpearman: %f",
                    cor(x = promoters[["chip_atlas"]][["coverage"]],
                        y = promoter_score,
                        method = "spearman")),
     xlab = "promoter coverage",
     ylab = "log10(promoter score)")

# Promoters coverage vs width
par(mfrow = c(1, 2), cex = 0.7, pty = "s")
graphics::smoothScatter(
     x = promoters[["remap"]][["coverage"]],
     y = promoter_width,
     main = sprintf("ReMap2020\npromoters coverage vs width\nSpearman: %f",
                    cor(x = promoters[["remap"]][["coverage"]],
                        y = promoter_width,
                        method = "spearman")),
     xlab = "promoter coverage",
     ylab = "promoter width")
graphics::smoothScatter(
     x = promoters[["chip_atlas"]][["coverage"]],
     y = promoter_width,
     main = sprintf("ChIP-Atlas\npromoters coverage vs width\nSpearman: %f",
                    cor(x = promoters[["chip_atlas"]][["coverage"]],
                        y = promoter_width,
                        method = "spearman")),
     xlab = "promoter coverage",
     ylab = "promoter width")
```

### Protein Atlas gene specificity classification

We investigate promoters coverage by looking at their target genes 
classification in terms of tissue/cell type specificity as defined by Protein 
Atlas.

> The RNA specificity category is based on mRNA expression levels in a 
combination of data from HPA, GTEX and FANTOM5. The categories include: tissue enriched, group enriched, tissue enhanced, low tissue specificity and not 
detected.

>
+ Enriched - NX level in a particular tissue/region/cell type at least four 
times any other tissue/cell type.
+ Group enriched - NX levels of a group (2-5 tissues or 2-10 cell types) at 
least four times any other tissue/cell type.
+ Enhanced - NX levels of a group (1-5 tissues or 1-10 cell types) at least four 
times the mean of other tissue/cell types.
+ Low specificity - NX >= 1 in at least one tissue/cell type but not elevated in 
any tissue/cell type.
+ Not detected - NX < 1 in all tissue/cell types.

[Protein Atlas](https://www.proteinatlas.org/about/assays+annotation#classification_rna)

```{r protein_atlas_promoters}
promoters_meta <- GenomicRanges::mcols(promoters_f5_core) %>%
    as.data.frame() %>%
    dplyr::left_join(y = protein_atlas[, c(
        "Gene",
        "RNA tissue specificity",
        "RNA single cell type specificity"
    )],
    by = c("SYMBOL" = "Gene"))
stopifnot(all(promoters_meta$name == promoters[["remap"]][["nm"]]))
stopifnot(all(promoters_meta$name == promoters[["chip_atlas"]][["nm"]]))
promoters_meta$remap_coverage <- promoters[["remap"]][["coverage"]]
promoters_meta$chip_atlas_coverage <- promoters[["chip_atlas"]][["coverage"]]

# RNA tissue specificity
par(mfrow = c(1, 2), cex = 0.7, pty = "s")
graphics::boxplot(remap_coverage ~ `RNA tissue specificity`, 
                  data = promoters_meta,
                  main = "ReMap2020\nProtein Atlas tissue specificity",
                  ylab = "promoter coverage",
                  xlab = "",
                  las=2,
                  cex.names = 0.4)
graphics::boxplot(chip_atlas_coverage ~ `RNA tissue specificity`, 
                  data = promoters_meta,
                  main = "ChIP-Atlas\nProtein Atlas tissue specificity",
                  ylab = "promoter coverage",
                  xlab = "",
                  las=2,
                  cex.names = 0.4)

# RNA single cell type specificity
par(mfrow = c(1, 2), cex = 0.7, pty = "s")
graphics::boxplot(remap_coverage ~ `RNA single cell type specificity`, 
                  data = promoters_meta,
                  main = "ReMap2020\nProtein Atlas single cell type specificity",
                  ylab = "promoter coverage",
                  xlab = "",
                  las=2,
                  cex.names = 0.4)
graphics::boxplot(chip_atlas_coverage ~ `RNA single cell type specificity`, 
                  data = promoters_meta,
                  main = "ChIP-Atlas\nProtein Atlas single cell type specificity",
                  ylab = "promoter coverage",
                  xlab = "",
                  las=2,
                  cex.names = 0.4)
```

### FANTOM5 promoter specificity

To generalize the idea of promoter tissue/cell type specificity to promoters 
outside Protein Atlas annotation we define specificity score based on the 
FANTOM5 CAGE data.

The  can be defined in multiple ways. Here we calculate expression based 
specificity score using $\tau$ metric defined as

$\tau = \frac{\sum_{i=1}^{n} (1-\hat{x_i})}{n-1}; \hat{x_i} = \frac{x_i}{max(x)}$

Tau varies from 0 to 1, where 0 means broadly expressed, and 1 is specific.

[reference](https://academic.oup.com/bib/article/18/2/205/2562739#119555186).

```{r promoter_f5_specificity}
promoters_f5_core_expression <- 
    promoters_f5_expression[`00Annotation` %in% promoters_f5_core$name, ]
promoters_f5_core_expression[promoters[["remap"]],
                             remap_coverage := coverage,
                             on = c("00Annotation" = "nm")]
promoters_f5_core_expression[promoters[["chip_atlas"]],
                             chip_atlas_coverage := coverage,
                             on = c("00Annotation" = "nm")]
data.table::setDT(promoters_meta)
promoters_f5_core_expression[promoters_meta,
                             tissue_specificity := `RNA tissue specificity`,
                             on = c("00Annotation" = "name")]
```

```{r promoter_f5_specificity_boxplot}
graphics::boxplot(tau ~ tissue_specificity, 
                  data = promoters_f5_core_expression,
                  main = "Tissue specificity by tau vs Protein Atlass classififcation",
                  ylab = expression(tau),
                  xlab = "",
                  cex.axis = 0.4)
```


```{r promoters_f5_tau_hist}
coverageHist(x = promoters_f5_core_expression$tau,
             main = expression(paste("core promoters ", tau, " distribution")))
```

```{r promoter_f5_specificity_scatter}
par(mfrow = c(1, 2), cex = 0.7, pty = "s", mgp=c(2,1,0)) # default par(mgp=c(3,1,0))
with(
  promoters_f5_core_expression,
  graphics::smoothScatter(
    x = remap_coverage,
    y = tau,
    main = sprintf(
      "ReMap2020\npromoter specificity by tau\nSpearman: %f",
      cor(x = remap_coverage,
          y = tau,
          method = "spearman")
    ),
    ylab = expression(tau),
    xlab = "promoter coverage"
  )
)
with(
  promoters_f5_core_expression,
  graphics::smoothScatter(
    x = chip_atlas_coverage,
    y = tau,
    main = sprintf(
      "ChIP-Atlas\npromoter specificity by tau\nSpearman: %f",
      cor(x = chip_atlas_coverage,
          y = tau,
          method = "spearman")
    ),
    ylab = expression(tau),
    xlab = "promoter coverage"
  )
)
```

### Promoters co-correlation

???

```{r}
# # Function calculates between columns correlation over sparse matrix
# # Taken from https://stackoverflow.com/questions/5888287/running-cor-or-any-variant-over-a-sparse-matrix-in-r
# sparse.cor <- function(x){
#     n <- nrow(x)
# 
#     cMeans <- Matrix::colMeans(x)
#     cSums <- Matrix::colSums(x)
# 
#     # Calculate the population covariance matrix.
#     # There's no need to divide by (n-1) as the std. dev is also calculated the same way.
#     # The code is optimized to minize use of memory and expensive operations
#     covmat <- Matrix::tcrossprod(cMeans, (-2 * cSums + n * cMeans))
#     crossp <- Matrix::as.matrix(Matrix::crossprod(x))
#     covmat <- covmat + crossp
# 
#     sdvec <- sqrt(Matrix::diag(covmat)) # standard deviations of columns
#     covmat / Matrix::crossprod(Matrix::t(sdvec)) # correlation matrix
# }
# 
# # generally the core matrix is small enough to use stats::cor
# cc <- sparse.cor(Matrix::t(remap_promoters_core))
# 
# # but not small enough to plot correlation heatmap
# cc[upper.tri(cc)] %>% hist()
# 
# cc_spearman <- cor(x = as.matrix(remap_promoters_core), method = "spearman")
# cc_spearman[upper.tri(cc_spearman)] %>% hist()

# shared_pairs_remap <- lapply(
#     X = 1:100, 
#     FUN = function(i) {
#         idx <- sample(x = rownames(remap_promoters_core),
#                       size = 100,
#                       replace = FALSE)
#         getSharedColumnsPairs(remap_promoters_core[idx, ])
#     })

# How does the number of shared TFs depends on how many top promoters we are
# looking at?
# shared_tf <- c()
# shared_tf_nprom <- c()
# x <- seq(from = 1, to = 3322, by = 50)
# for (n in x) {
#     sel <- remap_promoters_core[remap_promoters_counts >= n, , drop = FALSE]
#     shared_tf_nprom <- c(shared_tf_nprom, nrow(sel))
#     n_tf <- sel %>%
#         getSharedColumns() %>%
#         sum()
#     shared_tf <- c(shared_tf, n_tf)
# }
# plot(x = x,
#      y = shared_tf,
#      main = "ReMap2020 promoters coverage vs number of shared TFs",
#      xlab = "promoter coverage >= x",
#      ylab = "number of shared TFs")
# plot(x = shared_tf_nprom,
#      y = shared_tf,
#      main = "ReMap2020 number of promoters vs number of shared TFs",
#      xlab = "number of promoters",
#      ylab = "number of shared TFs")
```

## Looking at promoter TF interaction matrix row wise (promoter wise) - lncRNA

Next we have limited our analysis to promoters of lncRNA defined as 
promoters associated with a lncRNA gene (as per GENCODE 38) and supported by 
ENCODE ROADMAP data. Finally, we select one promoter per associated gene that 
have maximum FANTOM5 score.
   
```{r core_lncRNA}
gc()

# only lncRNA genes as per GENCODE annotation
promoters_f5_lncRNA <- 
    promoters_f5[promoters_f5$gene_type_gencode == "lncRNA", ]

# ENCODE ROADMAP confirmation
roadmap_promoters <- rtracklayer::import.bed(
    con = system.file(
        "inst",
        "extdata",
        "Epigenome5DRoadmapDHS_promoter_hg38_liftOver.bed",
        package = "xcore"
    )
)
GenomeInfoDb::seqlevels(roadmap_promoters, pruning.mode = "coarse") <-
    GenomeInfoDb::seqlevels(promoters_f5_lncRNA)
promoters_f5_lncRNA <- intersectGr(promoters_f5_lncRNA, roadmap_promoters)

# Select best promoter per gene
best_promoters <- GenomicRanges::mcols(promoters_f5_lncRNA) %>%
    as.data.frame() %>%
    dplyr::group_by(SYMBOL) %>%
    dplyr::slice(which.max(score)) %>%
    dplyr::pull(name)
promoters_f5_lncRNA <-
    promoters_f5_lncRNA[promoters_f5_lncRNA$name %in% best_promoters, ]

# restrict interaction matrices to core promoters only
remap_promoters_lncRNA <- remap_promoters[promoters_f5_lncRNA$name, ]
chip_atlas_promoters_lncRNA <- chip_atlas_promoters[promoters_f5_lncRNA$name, ]
```

This give us an interaction matrix with `r nrow(remap_promoters_lncRNA)` promoters
(rows) and `r ncol(remap_promoters_lncRNA)`, `r ncol(chip_atlas_promoters_lncRNA)` 
ChIP-seq experiments (columns) for ReMap2020, ChIP-Atlas respectively.

### lncRNA coverage

```{r lncRNA_coverage}
chip_atlas_promoters_lncRNA <- as(chip_atlas_promoters_lncRNA, "dgCMatrix")
lncRNA <- list(
    remap = data.table::data.table(
        nm = remap_promoters_lncRNA %>% rownames(),
        coverage = remap_promoters_lncRNA %>% Matrix::rowSums(),
        tf_coverage = remap_promoters_lncRNA %>% getCoverage(col = 2, sep = "\\."),
        con_coverage = remap_promoters_lncRNA %>% getCoverage(col = 3, sep = "\\.")
    ),
    chip_atlas = data.table::data.table(
        nm = chip_atlas_promoters_lncRNA %>% rownames(),
        coverage = chip_atlas_promoters_lncRNA %>% Matrix::rowSums(),
        tf_coverage = chip_atlas_promoters_lncRNA %>%
            getCoverage(col = 1, sep = "_"),
        con_coverage = chip_atlas_promoters_lncRNA %>%
            getCoverage(col = 3, sep = "_")
    )
)
```

```{r lncRNA_coverage_hist}
# lncRNA coverage histogram
par(mfrow = c(1, 2), cex = 0.7, pty = "s")
coverageHist(x = lncRNA[["remap"]][["coverage"]],
             main = "ReMap2020 lncRNA coverage")
coverageHist(x = lncRNA[["chip_atlas"]][["coverage"]], 
             main = "ChIP-Atlas lncRNA coverage")

# lncRNA TF coverage histogram
par(mfrow = c(1, 2), cex = 0.7, pty = "s")
coverageHist(x = lncRNA[["remap"]][["tf_coverage"]],
             main = "ReMap2020 lncRNA TF coverage")
coverageHist(x = lncRNA[["chip_atlas"]][["tf_coverage"]], 
             main = "ChIP-Atlas lncRNA TF coverage")

# lncRNA biological context coverage histogram
par(mfrow = c(1, 2), cex = 0.7, pty = "s")
coverageHist(x = lncRNA[["remap"]][["con_coverage"]],
             main = "ReMap2020 lncRNA context coverage")
coverageHist(x = lncRNA[["chip_atlas"]][["con_coverage"]], 
             main = "ChIP-Atlas lncRNA context coverage")
```

For some lncRNA we observe no coverage at all:
`r sum(lncRNA[["remap"]][["coverage"]] == 0)`,
`r sum(lncRNA[["chip_atlas"]][["coverage"]] == 0)`
for ReMap2020, ChIP-Atlas respectively.

### ENCODE blacklist

```{r blacklisted_lncRNA}
par(mfrow = c(1, 2), cex = 0.7, pty = "s")
blacklistBoxPlot(coverage = lncRNA[["remap"]][["coverage"]],
                 cov_names = lncRNA[["remap"]][["nm"]],
                 gr1 = blacklist,
                 aname = "blacklisted",
                 bname = "other",
                 main = "ReMap2020\nENCODE blacklisted regions",
                 ylab = "lncRNA coverage")
blacklistBoxPlot(coverage = lncRNA[["chip_atlas"]][["coverage"]],
                 cov_names = lncRNA[["chip_atlas"]][["nm"]],
                 gr1 = blacklist,
                 aname = "blacklisted",
                 bname = "other",
                 main = "ChIP-Atlas\nENCODE blacklisted regions",
                 ylab = "lncRNA coverage")
```

### Ensembl soft masked regions

```{r soft_masked_lncRNA}
par(mfrow = c(1, 2), cex = 0.7, pty = "s")
blacklistBoxPlot(coverage = lncRNA[["remap"]][["coverage"]],
                 cov_names = lncRNA[["remap"]][["nm"]],
                 gr1 = ensembl_sm,
                 aname = "soft masked",
                 bname = "other",
                 main = "ReMap2020\nEnsembl soft masked regions",
                 ylab = "lncRNA coverage")
blacklistBoxPlot(coverage = lncRNA[["chip_atlas"]][["coverage"]],
                 cov_names = lncRNA[["chip_atlas"]][["nm"]],
                 gr1 = ensembl_sm,
                 aname = "soft masked",
                 bname = "other",
                 main = "ChIP-Atlas\nEnsembl soft masked regions",
                 ylab = "lncRNA coverage")
```

### lncRNA promoters "phisical" properties

```{r lncRNA_score_length}
stopifnot(all(promoters_f5_lncRNA$name == lncRNA[["remap"]][["nm"]]))
stopifnot(all(promoters_f5_lncRNA$name == lncRNA[["chip_atlas"]][["nm"]]))

lncRNA_score <- log10(promoters_f5_lncRNA$score)
lncRNA_width <- GenomicRanges::width(promoters_f5_lncRNA)

# lncRNA coverage vs score
par(mfrow = c(1, 2), cex = 0.7, pty = "s")
graphics::smoothScatter(
     x = lncRNA[["remap"]][["coverage"]],
     y = lncRNA_score,
     main = sprintf("ReMap2020\nlncRNA promoter coverage vs F5 score\nSpearman: %f",
                    cor(x = lncRNA[["remap"]][["coverage"]],
                        y = lncRNA_score,
                        method = "spearman")),
     xlab = "lncRNA coverage",
     ylab = "log10(lncRNA score)")
graphics::smoothScatter(
     x = lncRNA[["chip_atlas"]][["coverage"]],
     y = lncRNA_score,
     main = sprintf("ChIP-Atlas\nlncRNA promoter coverage vs F5 score\nSpearman: %f",
                    cor(x = lncRNA[["chip_atlas"]][["coverage"]],
                        y = lncRNA_score,
                        method = "spearman")),
     xlab = "lncRNA promoter coverage",
     ylab = "log10(lncRNA score)")

# lncRNA coverage vs width
par(mfrow = c(1, 2), cex = 0.7, pty = "s")
graphics::smoothScatter(
     x = lncRNA[["remap"]][["coverage"]],
     y = lncRNA_width,
     main = sprintf("ReMap2020\nlncRNA coverage vs width\nSpearman: %f",
                    cor(x = lncRNA[["remap"]][["coverage"]],
                        y = lncRNA_width,
                        method = "spearman")),
     xlab = "lncRNA coverage",
     ylab = "lncRNA width")
graphics::smoothScatter(
     x = lncRNA[["chip_atlas"]][["coverage"]],
     y = lncRNA_width,
     main = sprintf("ChIP-Atlas\nlncRNA coverage vs width\nSpearman: %f",
                    cor(x = lncRNA[["chip_atlas"]][["coverage"]],
                        y = lncRNA_width,
                        method = "spearman")),
     xlab = "lncRNA coverage",
     ylab = "lncRNA width")
```

### FANTOM5 lncRNA specificity

```{r lncRNA_f5_specificity}
promoters_f5_lncRNA_expression <- 
    promoters_f5_expression[`00Annotation` %in% promoters_f5_lncRNA$name, ]
promoters_f5_lncRNA_expression[lncRNA[["remap"]],
                             remap_coverage := coverage,
                             on = c("00Annotation" = "nm")]
promoters_f5_lncRNA_expression[lncRNA[["chip_atlas"]],
                             chip_atlas_coverage := coverage,
                             on = c("00Annotation" = "nm")]
```

```{r lncRNA_f5_tau_hist}
coverageHist(x = promoters_f5_lncRNA_expression$tau,
             main = expression(paste("core lncRNA promoters ", tau, " distribution")))
```

```{r lncRNA_f5_specificity_scatter}
par(mfrow = c(1, 2), cex = 0.7, pty = "s", mgp=c(2,1,0)) # default par(mgp=c(3,1,0))
with(
  promoters_f5_lncRNA_expression,
  graphics::smoothScatter(
    x = remap_coverage,
    y = tau,
    main = sprintf(
      "ReMap2020\nlncRNA specificity by tau\nSpearman: %f",
      cor(x = remap_coverage,
          y = tau,
          method = "spearman")
    ),
    ylab = expression(tau),
    xlab = "lncRNA coverage"
  )
)
with(
  promoters_f5_lncRNA_expression,
  graphics::smoothScatter(
    x = chip_atlas_coverage,
    y = tau,
    main = sprintf(
      "ChIP-Atlas\nlncRNA specificity by tau\nSpearman: %f",
      cor(x = chip_atlas_coverage,
          y = tau,
          method = "spearman")
    ),
    ylab = expression(tau),
    xlab = "lncRNA coverage"
  )
)
```

## Looking at enhancers TF interaction matrix row wise (enhancers wise)

Next we have we look at enhancers defined as enhancers supported by ENCODE 
ROADMAP data.
   
```{r core_enhancers}
gc()

# ENCODE ROADMAP confirmation
roadmap_enhancers <- rtracklayer::import.bed(
    con = system.file(
        "inst",
        "extdata",
        "Epigenome5DRoadmapDHS_enhancer_hg38_liftOver.bed",
        package = "xcore"
    )
)
GenomeInfoDb::seqlevels(roadmap_enhancers, pruning.mode = "coarse") <-
    GenomeInfoDb::seqlevels(xcore::enhancers)
enhancers_core_gr <- intersectGr(xcore::enhancers, roadmap_enhancers)

# additionally we could think of using EP300 or repeat_dfam
# enhancers_core_gr <- enhancers_core_gr[enhancers_core_gr$ep300 == "EP300", ]

# restrict interaction matrices to core promoters only
remap_enhancers_core <- xcore::remap_enhancers[enhancers_core_gr$name, ]
chip_atlas_enhancers_core <- xcore::chip_atlas_enhancers[enhancers_core_gr$name, ]
```

This give us an interaction matrix with `r nrow(remap_enhancers_core)` enhancers
(rows) and `r ncol(remap_enhancers_core)`, `r ncol(chip_atlas_enhancers_core)` 
ChIP-seq experiments (columns) for ReMap2020, ChIP-Atlas respectively.

### Enhancers coverage

```{r enhancers_coverage}
remap_enhancers_core <- as(remap_enhancers_core, "dgCMatrix")
chip_atlas_enhancers_core <- as(chip_atlas_enhancers_core, "dgCMatrix")

enhancers_core <- list(
    remap = data.table::data.table(
        nm = remap_enhancers_core %>% rownames(),
        coverage = remap_enhancers_core %>% Matrix::rowSums(),
        tf_coverage = remap_enhancers_core %>% getCoverage(col = 2, sep = "\\."),
        con_coverage = remap_enhancers_core %>% getCoverage(col = 3, sep = "\\.")
    ),
    chip_atlas = data.table::data.table(
        nm = chip_atlas_enhancers_core %>% rownames(),
        coverage = chip_atlas_enhancers_core %>% Matrix::rowSums(),
        tf_coverage = chip_atlas_enhancers_core %>%
            getCoverage(col = 1, sep = "_"),
        con_coverage = chip_atlas_enhancers_core %>%
            getCoverage(col = 3, sep = "_")
    )
)
```

```{r enhancers_coverage_hist}
# enhancers coverage histogram
par(mfrow = c(1, 2), cex = 0.7, pty = "s")
coverageHist(x = enhancers_core[["remap"]][["coverage"]],
             main = "ReMap2020 enhancers coverage")
coverageHist(x = enhancers_core[["chip_atlas"]][["coverage"]], 
             main = "ChIP-Atlas enhancers coverage")

# enhancers TF coverage histogram
par(mfrow = c(1, 2), cex = 0.7, pty = "s")
coverageHist(x = enhancers_core[["remap"]][["tf_coverage"]],
             main = "ReMap2020 enhancers TF coverage")
coverageHist(x = enhancers_core[["chip_atlas"]][["tf_coverage"]], 
             main = "ChIP-Atlas enhancers TF coverage")

# enhancers biological context coverage histogram
par(mfrow = c(1, 2), cex = 0.7, pty = "s")
coverageHist(x = enhancers_core[["remap"]][["con_coverage"]],
             main = "ReMap2020 enhancers context coverage")
coverageHist(x = enhancers_core[["chip_atlas"]][["con_coverage"]], 
             main = "ChIP-Atlas enhancers context coverage")
```

For some enhancers we observe no coverage at all:
`r sum(enhancers_core[["remap"]][["coverage"]] == 0)`,
`r sum(enhancers_core[["chip_atlas"]][["coverage"]] == 0)`
for ReMap2020, ChIP-Atlas respectively.

### ENCODE blacklist

```{r blacklisted_enhancers}
par(mfrow = c(1, 2), cex = 0.7, pty = "s")
blacklistBoxPlot(coverage = enhancers_core[["remap"]][["coverage"]],
                 cov_names = enhancers_core[["remap"]][["nm"]],
                 gr1 = blacklist,
                 aname = "blacklisted",
                 bname = "other",
                 main = "ReMap2020\nENCODE blacklisted regions",
                 ylab = "enhancers coverage")
blacklistBoxPlot(coverage = enhancers_core[["chip_atlas"]][["coverage"]],
                 cov_names = enhancers_core[["chip_atlas"]][["nm"]],
                 gr1 = blacklist,
                 aname = "blacklisted",
                 bname = "other",
                 main = "ChIP-Atlas\nENCODE blacklisted regions",
                 ylab = "enhancers coverage")
```

### Ensembl soft masked regions

```{r soft_masked_enhancers}
par(mfrow = c(1, 2), cex = 0.7, pty = "s")
blacklistBoxPlot(coverage = enhancers_core[["remap"]][["coverage"]],
                 cov_names = enhancers_core[["remap"]][["nm"]],
                 gr1 = ensembl_sm,
                 aname = "soft masked",
                 bname = "other",
                 main = "ReMap2020\nEnsembl soft masked regions",
                 ylab = "enhancers coverage")
blacklistBoxPlot(coverage = enhancers_core[["chip_atlas"]][["coverage"]],
                 cov_names = enhancers_core[["chip_atlas"]][["nm"]],
                 gr1 = ensembl_sm,
                 aname = "soft masked",
                 bname = "other",
                 main = "ChIP-Atlas\nEnsembl soft masked regions",
                 ylab = "enhancers coverage")
```

### enhancers "phisical" properties

```{r enhancers_score_length}
stopifnot(all(enhancers_core_gr$name == enhancers_core[["remap"]][["nm"]]))
stopifnot(all(enhancers_core_gr$name == enhancers_core[["chip_atlas"]][["nm"]]))

# enhancers_score <- log10(enhancers_core_gr$score)
enhancers_width <- GenomicRanges::width(enhancers_core_gr)

# enhancers coverage vs width
par(mfrow = c(1, 2), cex = 0.7, pty = "s")
graphics::smoothScatter(
     x = enhancers_core[["remap"]][["coverage"]],
     y = enhancers_width,
     main = sprintf("ReMap2020\nenhancer coverage vs width\nSpearman: %f",
                    cor(x = enhancers_core[["remap"]][["coverage"]],
                        y = enhancers_width,
                        method = "spearman")),
     xlab = "enhancer coverage",
     ylab = "enhancer width")
graphics::smoothScatter(
     x = enhancers_core[["chip_atlas"]][["coverage"]],
     y = enhancers_width,
     main = sprintf("ChIP-Atlas\nenhancer coverage vs width\nSpearman: %f",
                    cor(x = enhancers_core[["chip_atlas"]][["coverage"]],
                        y = enhancers_width,
                        method = "spearman")),
     xlab = "enhancer coverage",
     ylab = "enhancer width")
```

### FANTOM5 enhancer specificity

```{r enhancers_f5_specificity}
enhancers_f5_core_expression <- 
    enhancers_f5_expression[`V1` %in% enhancers_core_gr$name, ]
enhancers_f5_core_expression[enhancers_core[["remap"]],
                             remap_coverage := coverage,
                             on = c("V1" = "nm")]
enhancers_f5_core_expression[enhancers_core[["chip_atlas"]],
                             chip_atlas_coverage := coverage,
                             on = c("V1" = "nm")]
```

```{r enhancers_f5_tau_hist}
coverageHist(x = enhancers_f5_core_expression$tau,
             main = expression(paste("core enhancers ", tau, " distribution")))
```

```{r enhancers_f5_specificity_scatter}
par(mfrow = c(1, 2), cex = 0.7, pty = "s", mgp=c(2,1,0)) # default par(mgp=c(3,1,0))
with(
  enhancers_f5_core_expression,
  graphics::smoothScatter(
    x = remap_coverage,
    y = tau,
    main = sprintf(
      "ReMap2020\nenhancer specificity by tau\nSpearman: %f",
      cor(x = remap_coverage,
          y = tau,
          method = "spearman")
    ),
    ylab = expression(tau),
    xlab = "enhancer coverage"
  )
)
with(
  enhancers_f5_core_expression,
  graphics::smoothScatter(
    x = chip_atlas_coverage,
    y = tau,
    main = sprintf(
      "ChIP-Atlas\nenhancer specificity by tau\nSpearman: %f",
      cor(x = chip_atlas_coverage,
          y = tau,
          method = "spearman")
    ),
    ylab = expression(tau),
    xlab = "enhancer coverage"
  )
)
```

## Looking at promoter TF interaction matrix column wise (TF wise)

```{r tf_coverage_remap}
remap_tf_counts <- remap_promoters_core %>%
    Matrix::colSums()

remap_tf_counts %>%
    summary()

remap_tf_counts %>%
    `/`(nrow(remap_promoters_core)) %>%
    summary()

remap_tf_counts %>%
    graphics::hist(breaks = 100,
                   plot = TRUE,
                   main = "ReMap2020 TFs coverage")

# ZERO TFs
(remap_tf_counts == 0) %>% table() / length(remap_tf_counts)
(m <- remap_tf_counts == 0) %>% sum()
names(m)[m]

# How many TFs overlapp X% or more promoters
vapply(X = seq(from = 0, to = 1, by = 0.1),
       FUN = function(x) sum(remap_tf_counts >= (nrow(remap_promoters_core) * x)),
       FUN.VALUE = numeric(1L)) %>%
    stats::setNames(nm = seq(from = 0, to = 100, by = 10))
# what are the top TFs?
remap_tf_counts %>%
    sort(decreasing = TRUE) %>%
    as.data.frame() %>%
    head(30)
```

```{r tf_coverage_chip_atlas}
chip_atlas_tf_counts <- chip_atlas_promoters_core %>%
    Matrix::colSums()

chip_atlas_tf_counts %>%
    summary()

chip_atlas_tf_counts %>%
    `/`(nrow(chip_atlas_promoters_core)) %>%
    summary()

chip_atlas_tf_counts %>%
    graphics::hist(breaks = 100,
                   plot = TRUE,
                   main = "ChIP-Atlas TFs coverage")

(chip_atlas_tf_counts == 0) %>% table() / length(chip_atlas_tf_counts)
(m <- chip_atlas_tf_counts == 0) %>% sum()

# How many TFs overlapp X% or more promoters
vapply(X = seq(from = 0, to = 1, by = 0.1),
       FUN = function(x) {
           sum(chip_atlas_tf_counts >= (nrow(chip_atlas_promoters_core) * x))
       },
       FUN.VALUE = numeric(1L)) %>%
    stats::setNames(nm = seq(from = 0, to = 100, by = 10))
# what are the top TFs?
chip_atlas_tf_counts %>%
    sort(decreasing = TRUE) %>%
    as.data.frame() %>%
    head(30)
```
