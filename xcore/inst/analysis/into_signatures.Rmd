---
title: "Deeper look into the 'signatures'"
author: "Maciej Migda≈Ç"
output: pdf_document
---

```{r include=FALSE}
knitr::opts_chunk$set(warning = FALSE)

devtools::load_all()
library(data.table)
```

```{r functions_data, cache=TRUE, echo=FALSE, message=FALSE}
# Internally used variables
opar <- par()

# Internally used functions

# Function return logical vector indicating columns populated in all rows
# mat - object of class dgCMatrix with only 1 and 0 values
getSharedColumns <- function(mat) {
    stopifnot(is(mat, "dgCMatrix"))
    stopifnot(nrow(mat) > 0)

    Matrix::colSums(mat) == nrow(mat)
}

# Funtion return features from subject overlapped by query
# where subject, query are GRanges objects
# ... other arguments internally passed to GenomicRanges::findOverlaps
intersectGr <- function(subject, query, ...) {
    stopifnot(is(subject, "GRanges"))
    stopifnot(is(query, "GRanges"))

    hits <- GenomicRanges::findOverlaps(query = query, subject = subject, ...)
    i <- S4Vectors::subjectHits(hits)
    subject[i, ]
}

# Function returns all pairs of values in a vector; order in pair is not
# considered relevant
# x character vector of length > 1
getSharedColumnsPairs <- function(mat) {
    stopifnot(is(mat, "dgCMatrix"))
    stopifnot(nrow(mat) > 0)
    
    indexes <- combn(x = seq(from = 1, to = nrow(mat)), 
                     m = 2,
                     simplify = FALSE)
    vapply(X = indexes, 
           function(i) sum(Matrix::colSums(mat[i, ]) == 2), 
           FUN.VALUE = integer(1L))
}

# Function return summary as a string
summaryString <- function(...) {
    s <- summary(...)
    snm <- names(s)
    sval <- s %>% round(2) %>% as.character()
    len <- vapply(X = seq_along(snm), 
                  FUN = function(i) max(nchar(c(snm[i], sval[i]))) + 3L, 
                  FUN.VALUE = integer(1L))
    snm <- paste(vapply(
        X = seq_along(snm),
        FUN = function(i) stringr::str_pad(snm[i], len[i]),
        FUN.VALUE = character(1L)
        ), collapse = " ")
    sval <- paste(vapply(
        X = seq_along(sval),
        FUN = function(i) stringr::str_pad(sval[i], len[i] + 2),
        FUN.VALUE = character(1L)
        ), collapse = " ")
    paste0(snm, "\n", sval)
}

# Function calculates TF or Context coverage based on interaction matrix
# col to use for grouping
getCoverage <- function(mat, col = c(2, 3), sep = "\\.") {
    n <- stringr::str_count(colnames(mat)[1], sep)
    colnm <- colnames(mat) %>% 
        gsub(pattern = paste(c("(.*)", rep(c(sep, "(.*)"), n)), collapse = ""),
             replacement = paste0("\\", col))
    DelayedArray::colsum(x = mat, group = colnm %>% as.factor()) %>%
        `>`(1) %>%
        rowSums()
}

# Function plot coverage histogram
coverageHist<- function(x, breaks = 40, cex = 0.7, xlab = "", ...) {
    par(mar = c(5, 5, 6, 2))
    graphics::hist(x = x, 
                   breaks = breaks,
                   cex = 0.7,
                   xlab = xlab,
                   ...)
    mtext(text = summaryString(x), 
          side = 3,
          cex=0.6)
}

# Function plot two group box plot
blacklistBoxPlot <- function(coverage, cov_names, gr1, aname, bname, ...) {
    blk <- coverage[cov_names %in% gr1]
    nonblk <- coverage[! cov_names %in% gr1]
    aname <- paste0(aname, " (%i)")
    bname <- paste0(bname, " (%i)")

    graphics::boxplot(blk, nonblk,
                      names = c(sprintf(aname, length(blk)), 
                                sprintf(bname, length(nonblk))),
                      ...)
}

# Internally used datasets
# ENCODE blacklist list 636 regions spanning ~7% of human genome
blacklist <- rtracklayer::import(system.file("inst",
                                             "extdata",
                                             "hg38-blacklist.v2.bed.gz",
                                             package = "xcore")) %>%
    intersectGr(subject = promoters_f5, type = "any") %>%
    GenomicRanges::mcols() %>%
    `[[`("name")
    

# ENSEMBL soft mask list 4725854 regions spanning ~50% of human genome
ensembl_sm <- rtracklayer::import(system.file("inst",
                                              "extdata",
                                              "hg38_ensembl_sm.bed.gz",
                                              package = "xcore")) %>%
    intersectGr(subject = promoters_f5, type = "any") %>%
    GenomicRanges::mcols() %>%
    `[[`("name")

# Protein atlas
protein_atlas <-
    data.table::fread(
        file = system.file("inst", "extdata", "proteinatlas.tsv.gz", package = "xcore"),
        header = TRUE
    )[! duplicated(Gene), ]

# FANTOM5 promoter expression table
# Matrix of promoters normalized expression across datasets in FANTOM5, 
# column names are not imported!
promoters_f5_expression <-
    data.table::fread(
        file = system.file("inst",
                           "extdata",
                           "hg38_fair+new_CAGE_peaks_phase1and2_tpm.osc.txt.gz",
                           package = "xcore"),
        header = TRUE
    )

# tau calculation from on https://academic.oup.com/bib/article/18/2/205/2562739
#Function require a vector with expression of one gene in different tissues.
#If expression for one tissue is not known, gene specificity for this gene is NA
#Minimum 2 tissues
fTau <- function(x)
{
	if(all(!is.na(x)))
 	{
 		if(min(x, na.rm=TRUE) >= 0)
		{
 			if(max(x)!=0)
 			{
 				x <- (1-(x/max(x)))
 				res <- sum(x, na.rm=TRUE)
 				res <- res/(length(x)-1)
 			} else {
 				res <- 0
 			}
 		} else {
 		res <- NA
 		#print("Expression values have to be positive!")
 		} 
 	} else {
 		res <- NA
 		#print("No data for this gene avalable.")
 	} 
 	return(res)
}

#Hg entropy calculation from on https://academic.oup.com/bib/article/18/2/205/2562739
#Function require a vector with expression of one gene in different tissues.
#If expression for one tissue is not known, gene specificity for this gene is NA
fHg <- function(x)
{	
	if(all(!is.na(x)))
 	{
 		if(min(x, na.rm=TRUE) >= 0)
		{
 			if(sum(x) !=0)
 			{
 				p <- x / sum(x)
 				res <- -sum(p*log2(p), na.rm=TRUE)
 				res <- 1 - (res/log2(length(p))) #Modification: To bring to normalized scale
 			} else {
 				res <- 0
 			} 		
 		} else {
 		res <- NA
 		#print("Expression values have to be positive!")
 		}
 	} else {
 		res <- NA
 		#print("No data for this gene avalable.")
 	}
 	return(res)
}

promoters_f5_expression <-
    data.table::melt(data = promoters_f5_expression,
                     id.vars = "00Annotation")
promoters_f5_expression <- promoters_f5_expression[, .(
                         mean = mean(value, na.rm = TRUE),
                         min = min(value, na.rm = TRUE),
                         max = max(value, na.rm = TRUE),
                         sd = sd(value, na.rm = TRUE),
                         tau = fTau(log(value + 1)),
                         hg = fHg(log(value + 1)),
                         count = sum(value > 0.2)
                     ),
                     by = "00Annotation"]

gc()
```
# Technical biases and noise vs biological signal.

Based on the Bogumil's observation that some promoters always give a signal
regardless on the transcription factor we look at. As well as, some TF gives 
signal regardless of the promoter we look at. We set out with an exploratory 
data analysis on the ReMap2020 and ChIP-Atlas data sets.

ReMap2020 and ChIP-Atlas were intersected with FANTOM5 promoters into 
interaction matrices with ChIP-seq experiment as a columns and promoters as a
row names. Overall our data included `r nrow(remap_promoters)` promoters and
`r ncol(remap_promoters)`, `r ncol(chip_atlas_promoters)` ChIP-seq experiments
for ReMap2020, ChIP-Atlas respectively.

To look deeper into those data sets, first we have limited our analysis to 
core promoters defined as promoters associated with a protein coding gene (as
per GENCODE 38) and supported by ENCODE ROADMAP data. Finally, we select one
promoter per associated gene that have maximum FANTOM5 score.
   
```{r core_promoters}
# only protein coding genes as per GENCODE annotation
promoters_f5_core <- 
    promoters_f5[promoters_f5$gene_type_gencode == "protein_coding", ]

# ENCODE ROADMAP confirmation
roadmap_promoters <- rtracklayer::import.bed(
    con = system.file(
        "inst",
        "extdata",
        "Epigenome5DRoadmapDHS_promoter_hg38_liftOver.bed",
        package = "xcore"
    )
)
GenomeInfoDb::seqlevels(roadmap_promoters, pruning.mode = "coarse") <-
    GenomeInfoDb::seqlevels(promoters_f5_core)
promoters_f5_core <- intersectGr(promoters_f5_core, roadmap_promoters)

# Select best promoter per gene
best_promoters <- GenomicRanges::mcols(promoters_f5_core) %>%
    as.data.frame() %>%
    dplyr::group_by(SYMBOL) %>%
    dplyr::slice(which.max(score)) %>%
    dplyr::pull(name)
promoters_f5_core <-
    promoters_f5_core[promoters_f5_core$name %in% best_promoters, ]

# restrict interaction matrices to core promoters only
remap_promoters_core <- remap_promoters[promoters_f5_core$name, ]
chip_atlas_promoters_core <- chip_atlas_promoters[promoters_f5_core$name, ]
```

This give us an interaction matrix with `r nrow(remap_promoters_core)` promoters
(rows) and `r ncol(remap_promoters_core)`, `r ncol(chip_atlas_promoters_core)` 
ChIP-seq experiments (columns) for ReMap2020, ChIP-Atlas respectively.

## Looking at promoter TF interaction matrix row wise (promoter wise)

### Promoter coverage

For each promoter we calculate coverage which is equal to the number
of ChIP-seq experiment the promoter intersect with. Additionally we calculate 
the TF coverage equal to the number of different TFs the promoter intersect 
with. And biological context coverage which is equal to the number of different 
biological contexts (eg. tissue, cell) promoter intersect with. 

<!-- TODO experiment coverage -->

```{r promoters_coverage}
chip_atlas_promoters_core <- as(chip_atlas_promoters_core, "dgCMatrix")
promoters <- list(
    remap = data.table::data.table(
        nm = remap_promoters_core %>% rownames(),
        coverage = remap_promoters_core %>% Matrix::rowSums(),
        tf_coverage = remap_promoters_core %>% getCoverage(col = 2, sep = "\\."),
        con_coverage = remap_promoters_core %>% getCoverage(col = 3, sep = "\\.")
    ),
    chip_atlas = data.table::data.table(
        nm = chip_atlas_promoters_core %>% rownames(),
        coverage = chip_atlas_promoters_core %>% Matrix::rowSums(),
        tf_coverage = chip_atlas_promoters_core %>%
            getCoverage(col = 1, sep = "_"),
        con_coverage = chip_atlas_promoters_core %>%
            getCoverage(col = 3, sep = "_")
    )
)
```

```{r promoters_coverage_hist}
# Promoter coverage histogram
par(mfrow = c(1, 2), cex = 0.7, pty = "s")
coverageHist(x = promoters[["remap"]][["coverage"]],
             main = "ReMap2020 promoter coverage")
coverageHist(x = promoters[["chip_atlas"]][["coverage"]], 
             main = "ChIP-Atlas promoter coverage")

# Promoter TF coverage histogram
par(mfrow = c(1, 2), cex = 0.7, pty = "s")
coverageHist(x = promoters[["remap"]][["tf_coverage"]],
             main = "ReMap2020 promoter TF coverage")
coverageHist(x = promoters[["chip_atlas"]][["tf_coverage"]], 
             main = "ChIP-Atlas promoter TF coverage")

# Promoter biological context coverage histogram
par(mfrow = c(1, 2), cex = 0.7, pty = "s")
coverageHist(x = promoters[["remap"]][["con_coverage"]],
             main = "ReMap2020 promoter context coverage")
coverageHist(x = promoters[["chip_atlas"]][["con_coverage"]], 
             main = "ChIP-Atlas promoter context coverage")
```

For some promoters we observe no coverage at all:
`r sum(promoters[["remap"]][["coverage"]] == 0)`,
`r sum(promoters[["chip_atlas"]][["coverage"]] == 0)`
for ReMap2020, ChIP-Atlas respectively.

### ENCODE blacklist

We investigate promoters coverage by overlapping the promoters with ENCODE's 
list of blacklisted regions.

>  ENCODE blacklist is a comprehensive set of regions in the human and other 
genomes that have anomalous, unstructured, or high signal in next-generation 
sequencing experiments independent of cell line or experiment. The removal of 
the ENCODE blacklist is an essential quality measure when analyzing functional 
genomics data.
[ENCODE blacklist](https://github.com/Boyle-Lab/Blacklist)

```{r blacklisted_promoters}
par(mfrow = c(1, 2), cex = 0.7, pty = "s")
blacklistBoxPlot(coverage = promoters[["remap"]][["coverage"]],
                 cov_names = promoters[["remap"]][["nm"]],
                 gr1 = blacklist,
                 aname = "blacklisted",
                 bname = "other",
                 main = "ReMap2020\nENCODE blacklisted regions",
                 ylab = "promoter coverage")
blacklistBoxPlot(coverage = promoters[["chip_atlas"]][["coverage"]],
                 cov_names = promoters[["chip_atlas"]][["nm"]],
                 gr1 = blacklist,
                 aname = "blacklisted",
                 bname = "other",
                 main = "ChIP-Atlas\nENCODE blacklisted regions",
                 ylab = "promoter coverage")
```

### Ensembl soft masked regions

We investigate promoters coverage by overlapping the promoters with Ensembl's 
list of soft masked regions.

> Repetitive sequence is found throughout genomes. Ensembl mask repeats using 
Repeat Masker and Dust. 
[assembly repeats](https://www.ensembl.org/info/genome/genebuild/assembly_repeats.html)

```{r soft_masked_promoters}
par(mfrow = c(1, 2), cex = 0.7, pty = "s")
blacklistBoxPlot(coverage = promoters[["remap"]][["coverage"]],
                 cov_names = promoters[["remap"]][["nm"]],
                 gr1 = ensembl_sm,
                 aname = "soft masked",
                 bname = "other",
                 main = "ReMap2020\nEnsembl soft masked regions",
                 ylab = "promoter coverage")
blacklistBoxPlot(coverage = promoters[["chip_atlas"]][["coverage"]],
                 cov_names = promoters[["chip_atlas"]][["nm"]],
                 gr1 = ensembl_sm,
                 aname = "soft masked",
                 bname = "other",
                 main = "ChIP-Atlas\nEnsembl soft masked regions",
                 ylab = "promoter coverage")
```

### Promoters "phisical" properties

We investigate promoters coverage by looking at the relations between promoter
coverage and promoter FANTOM5 score, or width.

```{r promoter_score_length}
stopifnot(all(promoters_f5_core$name == promoters[["remap"]][["nm"]]))
stopifnot(all(promoters_f5_core$name == promoters[["chip_atlas"]][["nm"]]))

promoter_score <- log10(promoters_f5_core$score)
promoter_width <- GenomicRanges::width(promoters_f5_core)

# Promoters coverage vs score
par(mfrow = c(1, 2), cex = 0.7, pty = "s")
graphics::smoothScatter(
     x = promoters[["remap"]][["coverage"]],
     y = promoter_score,
     main = sprintf("ReMap2020\npromoters coverage vs F5 score\nPearson: %f",
                    cor(x = promoters[["remap"]][["coverage"]],
                        y = promoter_score,
                        method = "pearson")),
     xlab = "promoter coverage",
     ylab = "log10(promoter score)")
graphics::smoothScatter(
     x = promoters[["chip_atlas"]][["coverage"]],
     y = promoter_score,
     main = sprintf("ChIP-Atlas\npromoters coverage vs F5 score\nPearson: %f",
                    cor(x = promoters[["chip_atlas"]][["coverage"]],
                        y = promoter_score,
                        method = "pearson")),
     xlab = "promoter coverage",
     ylab = "log10(promoter score)")

# Promoters coverage vs width
par(mfrow = c(1, 2), cex = 0.7, pty = "s")
graphics::smoothScatter(
     x = promoters[["remap"]][["coverage"]],
     y = promoter_width,
     main = sprintf("ReMap2020\npromoters coverage vs width\nPearson: %f",
                    cor(x = promoters[["remap"]][["coverage"]],
                        y = promoter_width,
                        method = "pearson")),
     xlab = "promoter coverage",
     ylab = "promoter width")
graphics::smoothScatter(
     x = promoters[["chip_atlas"]][["coverage"]],
     y = promoter_width,
     main = sprintf("ChIP-Atlas\npromoters coverage vs width\nPearson: %f",
                    cor(x = promoters[["chip_atlas"]][["coverage"]],
                        y = promoter_width,
                        method = "pearson")),
     xlab = "promoter coverage",
     ylab = "promoter width")
```

### Protein Atlas gene specificity classification

We investigate promoters coverage by looking at their target genes 
classification in terms of tissue/cell type specificity as defined by Protein 
Atlas.

> The RNA specificity category is based on mRNA expression levels in a 
combination of data from HPA, GTEX and FANTOM5. The categories include: tissue enriched, group enriched, tissue enhanced, low tissue specificity and not 
detected.

>
+ Enriched - NX level in a particular tissue/region/cell type at least four 
times any other tissue/cell type.
+ Group enriched - NX levels of a group (2-5 tissues or 2-10 cell types) at 
least four times any other tissue/cell type.
+ Enhanced - NX levels of a group (1-5 tissues or 1-10 cell types) at least four 
times the mean of other tissue/cell types.
+ Low specificity - NX >= 1 in at least one tissue/cell type but not elevated in 
any tissue/cell type.
+ Not detected - NX < 1 in all tissue/cell types.

[Protein Atlas](https://www.proteinatlas.org/about/assays+annotation#classification_rna)

```{r protein_atlas_promoters}
promoters_meta <- GenomicRanges::mcols(promoters_f5_core) %>%
    as.data.frame() %>%
    dplyr::left_join(y = protein_atlas[, c(
        "Gene",
        "RNA tissue specificity",
        "RNA single cell type specificity"
    )],
    by = c("SYMBOL" = "Gene"))
stopifnot(all(promoters_meta$name == promoters[["remap"]][["nm"]]))
stopifnot(all(promoters_meta$name == promoters[["chip_atlas"]][["nm"]]))
promoters_meta$remap_coverage <- promoters[["remap"]][["coverage"]]
promoters_meta$chip_atlas_coverage <- promoters[["chip_atlas"]][["coverage"]]

# RNA tissue specificity
par(mfrow = c(1, 2), cex = 0.7, pty = "s")
graphics::boxplot(remap_coverage ~ `RNA tissue specificity`, 
                  data = promoters_meta,
                  main = "ReMap2020\nProtein Atlas tissue specificity",
                  ylab = "promoter coverage",
                  xlab = "",
                  las=2,
                  cex.names = 0.4)
graphics::boxplot(chip_atlas_coverage ~ `RNA tissue specificity`, 
                  data = promoters_meta,
                  main = "ChIP-Atlas\nProtein Atlas tissue specificity",
                  ylab = "promoter coverage",
                  xlab = "",
                  las=2,
                  cex.names = 0.4)

# RNA single cell type specificity
par(mfrow = c(1, 2), cex = 0.7, pty = "s")
graphics::boxplot(remap_coverage ~ `RNA single cell type specificity`, 
                  data = promoters_meta,
                  main = "ReMap2020\nProtein Atlas single cell type specificity",
                  ylab = "promoter coverage",
                  xlab = "",
                  las=2,
                  cex.names = 0.4)
graphics::boxplot(chip_atlas_coverage ~ `RNA single cell type specificity`, 
                  data = promoters_meta,
                  main = "ChIP-Atlas\nProtein Atlas single cell type specificity",
                  ylab = "promoter coverage",
                  xlab = "",
                  las=2,
                  cex.names = 0.4)
```

### FANTOM5 promoter specificity

To generalize the idea of promoter tissue/cell type specificity to promoters 
outside Protein Atlas annotation we define specificity score based on the 
FANTOM5 CAGE data.

The expression based specificity score can be defined in multiple ways. Here I
explore three of such definitions: counts, $\tau$ and $H_g$ based on a 
[reference](https://academic.oup.com/bib/article/18/2/205/2562739#119555186).

```{r promoter_f5_specificity}
promoters_f5_core_expression <- 
    promoters_f5_expression[`00Annotation` %in% promoters_f5_core$name, ]
promoters_f5_core_expression[promoters[["remap"]],
                             remap_coverage := coverage,
                             on = c("00Annotation" = "nm")]
promoters_f5_core_expression[promoters[["chip_atlas"]],
                             chip_atlas_coverage := coverage,
                             on = c("00Annotation" = "nm")]
data.table::setDT(promoters_meta)
promoters_f5_core_expression[promoters_meta,
                             tissue_specificity := `RNA tissue specificity`,
                             on = c("00Annotation" = "name")]
```

#### Counts 
are defined as a count of in how many tissues each gene is expressed.
The expression of a gene is decided based on a threshold. Here it is $0.2$ TPM.

$\sum_{i}^{b} [x_i > th]$, where $th$ is threshold


```{r promoter_f5_specificity_counts_boxplot}
# count (sum([Xi > 0.2]))
graphics::boxplot(count ~ tissue_specificity, 
                  data = promoters_f5_core_expression,
                  main = "Tissue specificity by count vs Protein Atlass classififcation",
                  ylab = expression(sum(x[i] > 0.2)),
                  xlab = "",
                  cex.axis = 0.4)
```

```{r promoter_f5_specificity_counts_scatter}
par(mfrow = c(1, 2), cex = 0.7, pty = "s", mgp=c(2,1,0)) # default par(mgp=c(3,1,0))
with(
  promoters_f5_core_expression,
  graphics::smoothScatter(
    x = remap_coverage,
    y = count,
    main = sprintf(
      "ReMap2020\npromoter specificity by counts\nPearson: %f",
      cor(x = remap_coverage,
          y = count,
          method = "pearson")
    ),
    ylab = expression(sum(x[i] > 0.2)),
    xlab = "promoter coverage"
  )
)
with(
  promoters_f5_core_expression,
  graphics::smoothScatter(
    x = chip_atlas_coverage,
    y = count,
    main = sprintf(
      "ChIP-Atlas\npromoter specificity by counts\nPearson: %f",
      cor(x = chip_atlas_coverage,
          y = count,
          method = "pearson")
    ),
    ylab = expression(sum(x[i] > 0.2)),
    xlab = "promoter coverage"
  )
)
```

#### Tau 
is defined as

$\tau = \frac{\sum_{i=1}^{n} (1-\hat{x_i})}{n-1}; \hat{x_i} = \frac{x_i}{max(x)}$

It has been shown to be the most robust metric.


```{r promoter_f5_specificity_tau_boxplot}
# tau
graphics::boxplot(tau ~ tissue_specificity, 
                  data = promoters_f5_core_expression,
                  main = "Tissue specificity by tau vs Protein Atlass classififcation",
                  ylab = expression(tau),
                  xlab = "",
                  cex.axis = 0.4)
```

```{r promoter_f5_specificity_tau_scatter}
par(mfrow = c(1, 2), cex = 0.7, pty = "s", mgp=c(2,1,0)) # default par(mgp=c(3,1,0))
with(
  promoters_f5_core_expression,
  graphics::smoothScatter(
    x = remap_coverage,
    y = tau,
    main = sprintf(
      "ReMap2020\npromoter specificity by tau\nPearson: %f",
      cor(x = remap_coverage,
          y = tau,
          method = "pearson")
    ),
    ylab = expression(tau),
    xlab = "promoter coverage"
  )
)
with(
  promoters_f5_core_expression,
  graphics::smoothScatter(
    x = chip_atlas_coverage,
    y = tau,
    main = sprintf(
      "ChIP-Atlas\npromoter specificity by tau\nPearson: %f",
      cor(x = chip_atlas_coverage,
          y = tau,
          method = "pearson")
    ),
    ylab = expression(tau),
    xlab = "promoter coverage"
  )
)
```

#### $H_g$ 
is a Shannon Entropy based tissue specificity metric, defined as

$-\sum_{i=1}^{n} p_{i} * log_{2} (p_{i}); p_{i} = \frac{x_i}{\sum_{i=1}^{n} x_i}$


```{r promoter_f5_specificity_hg_boxplot}
# Hg
graphics::boxplot(hg ~ tissue_specificity, 
                  data = promoters_f5_core_expression,
                  main = "Tissue specificity by Hg vs Protein Atlass classififcation",
                  ylab = expression(H[g]),
                  xlab = "",
                  cex.axis = 0.4)


```

```{r promoter_f5_specificity_hg_scatter}
par(mfrow = c(1, 2), cex = 0.7, pty = "s", mgp=c(2,1,0)) # default par(mgp=c(3,1,0))
with(
  promoters_f5_core_expression,
  graphics::smoothScatter(
    x = remap_coverage,
    y = hg,
    main = sprintf(
      "ReMap2020\npromoter specificity by Hg\nPearson: %f",
      cor(x = remap_coverage,
          y = hg,
          method = "pearson")
    ),
    ylab = expression(H[g]),
    xlab = "promoter coverage"
  )
)
with(
  promoters_f5_core_expression,
  graphics::smoothScatter(
    x = chip_atlas_coverage,
    y = hg,
    main = sprintf(
      "ChIP-Atlas\npromoter specificity by Hg\nPearson: %f",
      cor(x = chip_atlas_coverage,
          y = hg,
          method = "pearson")
    ),
    ylab = expression(H[g]),
    xlab = "promoter coverage"
  )
)
```

```{r}
# shared_pairs_remap <- lapply(
#     X = 1:100, 
#     FUN = function(i) {
#         idx <- sample(x = rownames(remap_promoters_core),
#                       size = 100,
#                       replace = FALSE)
#         getSharedColumnsPairs(remap_promoters_core[idx, ])
#     })

# How does the number of shared TFs depends on how many top promoters we are
# looking at?
# shared_tf <- c()
# shared_tf_nprom <- c()
# x <- seq(from = 1, to = 3322, by = 50)
# for (n in x) {
#     sel <- remap_promoters_core[remap_promoters_counts >= n, , drop = FALSE]
#     shared_tf_nprom <- c(shared_tf_nprom, nrow(sel))
#     n_tf <- sel %>%
#         getSharedColumns() %>%
#         sum()
#     shared_tf <- c(shared_tf, n_tf)
# }
# plot(x = x,
#      y = shared_tf,
#      main = "ReMap2020 promoters coverage vs number of shared TFs",
#      xlab = "promoter coverage >= x",
#      ylab = "number of shared TFs")
# plot(x = shared_tf_nprom,
#      y = shared_tf,
#      main = "ReMap2020 number of promoters vs number of shared TFs",
#      xlab = "number of promoters",
#      ylab = "number of shared TFs")
```

## Looking at promoter TF interaction matrix column wise (TF wise)

```{r tf_coverage_remap}
remap_tf_counts <- remap_promoters_core %>%
    Matrix::colSums()

remap_tf_counts %>%
    summary()

remap_tf_counts %>%
    `/`(nrow(remap_promoters_core)) %>%
    summary()

remap_tf_counts %>%
    graphics::hist(breaks = 100,
                   plot = TRUE,
                   main = "ReMap2020 TFs coverage")

# ZERO TFs
(remap_tf_counts == 0) %>% table() / length(remap_tf_counts)
(m <- remap_tf_counts == 0) %>% sum()
names(m)[m]

# How many TFs overlapp X% or more promoters
vapply(X = seq(from = 0, to = 1, by = 0.1),
       FUN = function(x) sum(remap_tf_counts >= (nrow(remap_promoters_core) * x)),
       FUN.VALUE = numeric(1L)) %>%
    stats::setNames(nm = seq(from = 0, to = 100, by = 10))
# what are the top TFs?
remap_tf_counts %>%
    sort(decreasing = TRUE) %>%
    as.data.frame() %>%
    head(30)
```

```{r tf_coverage_chip_atlas}
chip_atlas_tf_counts <- chip_atlas_promoters_core %>%
    Matrix::colSums()

chip_atlas_tf_counts %>%
    summary()

chip_atlas_tf_counts %>%
    `/`(nrow(chip_atlas_promoters_core)) %>%
    summary()

chip_atlas_tf_counts %>%
    graphics::hist(breaks = 100,
                   plot = TRUE,
                   main = "ChIP-Atlas TFs coverage")

(chip_atlas_tf_counts == 0) %>% table() / length(chip_atlas_tf_counts)
(m <- chip_atlas_tf_counts == 0) %>% sum()

# How many TFs overlapp X% or more promoters
vapply(X = seq(from = 0, to = 1, by = 0.1),
       FUN = function(x) {
           sum(chip_atlas_tf_counts >= (nrow(chip_atlas_promoters_core) * x))
       },
       FUN.VALUE = numeric(1L)) %>%
    stats::setNames(nm = seq(from = 0, to = 100, by = 10))
# what are the top TFs?
chip_atlas_tf_counts %>%
    sort(decreasing = TRUE) %>%
    as.data.frame() %>%
    head(30)
```
