---
title: "Deeper look into the 'signatures'"
author: "Maciej Migda≈Ç"
output: pdf_document
params:
  promoters_ann: promoters_f5
  annotation_name: FANTOM5
---

```{r include=FALSE}
knitr::opts_chunk$set(warning = FALSE, message = FALSE)

devtools::load_all()
library(data.table)

promoters_ann <- get0(params$promoters_ann)
```

# Core promoters
   
```{r core_promoters}
# only protein coding genes as per GENCODE annotation
promoters_ann_core <- 
    promoters_ann[promoters_ann$gene_type_gencode == "protein_coding", ]

# ENCODE ROADMAP confirmation
roadmap_promoters <- rtracklayer::import.bed(
    con = system.file(
        "inst",
        "extdata",
        "Epigenome5DRoadmapDHS_promoter_hg38_liftOver.bed",
        package = "xcore"
    )
)
GenomeInfoDb::seqlevels(roadmap_promoters, pruning.mode = "coarse") <-
    GenomeInfoDb::seqlevels(promoters_ann_core)
promoters_ann_core <- intersectGR(promoters_ann_core, roadmap_promoters)

# Select best promoter per gene
best_promoters <- GenomicRanges::mcols(promoters_ann_core) %>%
    as.data.frame() %>%
    dplyr::group_by(SYMBOL) %>%
    dplyr::slice(which.max(score)) %>%
    dplyr::pull(name)
promoters_ann_core <-
    promoters_ann_core[promoters_ann_core$name %in% best_promoters, ]

# restrict interaction matrices to core promoters only
remap_promoters_core <- remap_promoters[promoters_ann_core$name, ]
chip_atlas_promoters_core <- chip_atlas_promoters[promoters_ann_core$name, ]
```

# Per TF clustering core promoters, static cut, majority voting
DB filtering, at least 10 promoters not all promoters with signal

```{r}
hclustDist <- function(mat, method, cheight, cl_basename) {
  mat <- as.matrix(mat)
  d_mat <- if (method == "pearson") {
    sqrt(1 - cor(mat, method = "pearson")) %>% as.dist()
  } else {
    proxy::dist(x = mat, method = method, by_rows = FALSE)
  }
  
  hc <- hclust(d_mat, method = "ward.D2")
  cl <- cutree(hc, h = cheight)
  
  return(cl)
}
  
nameClusters <- function(cl, cl_basename) {
  vec_names <- names(cl)
  cl <- paste0(cl_basename, "_cl", cl, "_", max(cl))
  reps <- table(cl)
  cl <- paste0(cl, "_R", reps[cl])
  names(cl) <- vec_names
  
  return(cl)
}

makeClusteredX <- function(cl, X, alpha) {
  stopifnot(all(names(cl) == colnames(X)))
  
  intmat <- if (is.na(alpha)) {
    intvecs <- lapply(
      X = unique(cl),
      FUN = function(clu)
        Matrix::rowSums(X[, cl == clu, drop = FALSE], sparseResult = TRUE)
    )
    i <- do.call(c, lapply(intvecs, slot, "i"))
    j_lens <- vapply(intvecs, function(v) length(slot(v, "i")), numeric(1L))
    j <- do.call(c, lapply(seq_along(j_lens), function(l) rep(1L, times = j_lens[l]) * l))
    x <- do.call(c, lapply(intvecs, slot, "x"))
    Matrix::sparseMatrix(
      i = i,
      j = j,
      x = x,
      dimnames = list(rownames(X), levels(cl))
    )
  } else {
    do.call(
      what = cbind,
      args = lapply(
        X = unique(cl),
        FUN = function(clu)
          simplifyInteractionMatrix(
            mat = X[, names(cl)[cl == clu], drop = FALSE],
            alpha = alpha,
            colname = clu
          )
      )
    )
  }
  
  return(intmat)
}
```

## based on core promoters
# "0.05 Dice"
```{r}
cut_height <- seq(0.05, 0.21, by = 0.04) # seq(0.1, 2, by = 0.4)
alphas <- c(NA, 0.3, 0.5)
method <- c("Jaccard", "Dice", "Russel", "Tanimoto") # TODO finish pearson calc "pearson", missing rowsum
parm_grid <- expand.grid(cheight = cut_height, method = method)

for (db_name in c("remap", "chip_atlas")) {
  db <- get(paste0(db_name, "_promoters_core"))
  j <- (Matrix::colSums(db) >= 10) & (Matrix::colSums(db) != nrow(db))
  db <- db[, j]
  db_meta <- get(paste0(db_name, "_meta"))
  db_meta <- db_meta[id %in% colnames(db), ]
  tfs <- db_meta[, unique(tf)]
  for (i in seq_len(nrow(parm_grid))) {
    static <- c()
    method <- parm_grid[i, "method"]
    cheight <- parm_grid[i, "cheight"]
    print(paste0(cheight, " ", method))
    
    # per TF clustering
    for (tf_name in tfs) {
      print(tf_name)
      sigid <- db_meta[tf == tf_name, id]
      if (length(sigid) == 1) {
        cl_static <- stats::setNames(paste0(tf_name, "_cl1_1_R1"), sigid)
      } else {
        cl_static <- hclustDist(db[, sigid], method, cheight, tf_name)
        cl_static <- nameClusters(cl_static, tf_name)
      }
      
      static <- c(static, cl_static)
    }
    cl <- static[colnames(db)]
    meta <- data.table::data.table(id = names(cl), cluster = cl)
    data.table::fwrite(meta,
                       file = paste0("meta_", db_name, "_", method, "_", cheight))
    
    # core
    # for (alpha in alphas) {
    #   intmat <- get(paste0(db_name, "_promoters_core"))
    #   intmat <- intmat[, colnames(db)]
    #   a <- ifelse(is.na(alpha), "rowsum", alpha)
    #   out_name <- paste0(db_name, "_promoters_core_", method, "_", cheight, "_", a)
    #   intmat <- makeClusteredX(cl, intmat, alpha)
    #   assign(
    #     x = out_name,
    #     value = intmat
    #   )
    #   save(list = out_name,
    #       file = paste0(out_name, ".rda"))
    # }
    
    # all
    for (alpha in alphas) {
      intmat <- get(paste0(db_name, "_promoters"))
      intmat <- intmat[, colnames(db)]
      a <- ifelse(is.na(alpha), "rowsum", alpha)
      out_name <- paste0(db_name, "_promoters_", method, "_", cheight, "_", a)
      intmat <- makeClusteredX(cl, intmat, alpha)
      assign(
        x = out_name,
        value = intmat
      )
      save(list = out_name,
          file = paste0(out_name, ".rda"))
    }
  }
}
```

## based on promoter coding genes

promoters_ann[promoters_ann$gene_type_gencode == "protein_coding", ]

```{r}
cut_height <- seq(0.05, 0.21, by = 0.04) # seq(0.1, 2, by = 0.4)
alphas <- c(NA, 0.3, 0.5)
method <- c("pearson", "Gower", "Jaccard", "Dice", "Russel", "Tanimoto")
parm_grid <- expand.grid(cheight = cut_height, method = method)
dpis <- promoters_ann[promoters_ann$gene_type_gencode == "protein_coding", ]$name

for (db_name in c("remap", "chip_atlas")) {
  db <- get(paste0(db_name, "_promoters_core"))
  db <- db[dpis, ]
  j <- (Matrix::colSums(db) >= 10) & (Matrix::colSums(db) != nrow(db))
  db <- db[, j]
  db_meta <- get(paste0(db_name, "_meta"))
  db_meta <- db_meta[id %in% colnames(db), ]
  tfs <- db_meta[, unique(tf)]
  for (i in seq_len(nrow(parm_grid))) {
    static <- c()
    method <- parm_grid[i, "method"]
    cheight <- parm_grid[i, "cheight"]
    
    # per TF clustering
    for (tf_name in tfs) {
      sigid <- db_meta[tf == tf_name, id]
      if (length(sigid) == 1) {
        cl_static <- stats::setNames(paste0(tf_name, "_cl1_1_R1"), sigid)
      } else {
        cl_static <- hclustDist(db[, sigid], method, cheight, tf_name)
        cl_static <- nameClusters(cl_static, tf_name)
      }
      
      static <- c(static, cl_static)
    }
    cl <- static[colnames(db)]
    meta <- data.table::data.table(id = names(cl), cluster = cl)
    data.table::fwrite(meta,
                       file = paste0("meta_", db_name, "_protein_coding_", method, "_", cheight))
    
    # core
    # for (alpha in alphas) {
    #   intmat <- get(paste0(db_name, "_promoters_core"))
    #   intmat <- intmat[, colnames(db)]
    #   a <- ifelse(is.na(alpha), "rowsum", alpha)
    #   out_name <- paste0(db_name, "_protein_coding_promoters_core_", method, "_", cheight, "_", a)
    #   intmat <- makeClusteredX(cl, intmat, alpha)
    #   assign(
    #     x = out_name,
    #     value = intmat
    #   )
    #   save(list = out_name,
    #       file = paste0(out_name, ".rda"))
    # }
    
    # all
    for (alpha in alphas) {
      intmat <- get(paste0(db_name, "_promoters"))
      intmat <- intmat[, colnames(db)]
      a <- ifelse(is.na(alpha), "rowsum", alpha)
      out_name <- paste0(db_name, "_protein_coding_promoters_", method, "_", cheight, "_", a)
      intmat <- makeClusteredX(cl, intmat, alpha)
      assign(
        x = out_name,
        value = intmat
      )
      save(list = out_name,
          file = paste0(out_name, ".rda"))
    }
  }
}
```
